package cert

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/hex"
	"fmt"
	"math/big"
	"time"
)

// GenerateKeyPair generates a new ECDSA P-256 key pair.
// MASH requires P-256 (secp256r1) for all cryptographic operations.
func GenerateKeyPair() (*KeyPair, error) {
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("generate ECDSA key: %w", err)
	}

	return &KeyPair{
		PrivateKey: privateKey,
		PublicKey:  &privateKey.PublicKey,
	}, nil
}

// ComputeSKI computes the Subject Key Identifier from a public key.
// SKI is SHA-256 of the DER-encoded public key, truncated to 20 bytes.
func ComputeSKI(pub *ecdsa.PublicKey) ([]byte, error) {
	pubBytes, err := x509.MarshalPKIXPublicKey(pub)
	if err != nil {
		return nil, fmt.Errorf("marshal public key: %w", err)
	}

	hash := sha256.Sum256(pubBytes)
	return hash[:20], nil // Truncate to 20 bytes (160 bits)
}

// SKIToDeviceID converts a Subject Key Identifier to a device ID string.
// The device ID is the hex-encoded SKI.
func SKIToDeviceID(ski []byte) string {
	return hex.EncodeToString(ski)
}

// GenerateZoneCA creates a new Zone Certificate Authority.
// Zone CAs are generated by zone owners (controllers) and used to sign
// operational certificates for devices during commissioning.
func GenerateZoneCA(zoneID string, zoneType ZoneType) (*ZoneCA, error) {
	keyPair, err := GenerateKeyPair()
	if err != nil {
		return nil, fmt.Errorf("generate key pair: %w", err)
	}

	ski, err := ComputeSKI(keyPair.PublicKey)
	if err != nil {
		return nil, fmt.Errorf("compute SKI: %w", err)
	}

	serialNumber, err := generateSerialNumber()
	if err != nil {
		return nil, fmt.Errorf("generate serial number: %w", err)
	}

	now := time.Now()
	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   fmt.Sprintf("MASH Zone CA - %s", zoneID),
			Organization: []string{"MASH Zone"},
			OrganizationalUnit: []string{
				zoneType.String(),
				zoneID,
			},
		},
		NotBefore:             now,
		NotAfter:              now.Add(ZoneCAValidity),
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign | x509.KeyUsageDigitalSignature,
		BasicConstraintsValid: true,
		IsCA:                  true,
		MaxPathLen:            0, // Can only sign end-entity certificates
		MaxPathLenZero:        true,
		SubjectKeyId:          ski,
		AuthorityKeyId:        ski, // Self-signed: AKI == SKI
	}

	// Self-sign the CA certificate
	certDER, err := x509.CreateCertificate(rand.Reader, template, template, keyPair.PublicKey, keyPair.PrivateKey)
	if err != nil {
		return nil, fmt.Errorf("create certificate: %w", err)
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, fmt.Errorf("parse certificate: %w", err)
	}

	return &ZoneCA{
		Certificate: cert,
		PrivateKey:  keyPair.PrivateKey,
		ZoneID:      zoneID,
		ZoneType:    zoneType,
	}, nil
}

// CreateCSR creates a Certificate Signing Request for a device.
// The device generates this and sends it to the zone owner during commissioning.
func CreateCSR(keyPair *KeyPair, info *CSRInfo) ([]byte, error) {
	if keyPair == nil || keyPair.PrivateKey == nil {
		return nil, fmt.Errorf("key pair is required")
	}
	if info == nil {
		return nil, fmt.Errorf("CSR info is required")
	}

	template := &x509.CertificateRequest{
		Subject: pkix.Name{
			CommonName:   info.Identity.DeviceID,
			Organization: []string{"MASH Device"},
			OrganizationalUnit: []string{
				fmt.Sprintf("V%d", info.Identity.VendorID),
				fmt.Sprintf("P%d", info.Identity.ProductID),
			},
		},
		SignatureAlgorithm: x509.ECDSAWithSHA256,
	}

	// Add serial number if provided
	if info.Identity.SerialNumber != "" {
		template.Subject.SerialNumber = info.Identity.SerialNumber
	}

	csrDER, err := x509.CreateCertificateRequest(rand.Reader, template, keyPair.PrivateKey)
	if err != nil {
		return nil, fmt.Errorf("create CSR: %w", err)
	}

	return csrDER, nil
}

// SignCSR signs a Certificate Signing Request and issues an operational certificate.
// This is called by the zone owner (controller) during commissioning.
func SignCSR(ca *ZoneCA, csrDER []byte) (*x509.Certificate, error) {
	if ca == nil || ca.PrivateKey == nil || ca.Certificate == nil {
		return nil, fmt.Errorf("valid Zone CA is required")
	}

	csr, err := x509.ParseCertificateRequest(csrDER)
	if err != nil {
		return nil, fmt.Errorf("parse CSR: %w", err)
	}

	if err := csr.CheckSignature(); err != nil {
		return nil, fmt.Errorf("invalid CSR signature: %w", err)
	}

	// Extract public key for SKI computation
	pub, ok := csr.PublicKey.(*ecdsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("CSR must use ECDSA public key")
	}

	ski, err := ComputeSKI(pub)
	if err != nil {
		return nil, fmt.Errorf("compute SKI: %w", err)
	}

	serialNumber, err := generateSerialNumber()
	if err != nil {
		return nil, fmt.Errorf("generate serial number: %w", err)
	}

	now := time.Now()
	template := &x509.Certificate{
		SerialNumber:          serialNumber,
		Subject:               csr.Subject,
		NotBefore:             now,
		NotAfter:              now.Add(OperationalCertValidity),
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		IsCA:                  false,
		SubjectKeyId:          ski,
		AuthorityKeyId:        ca.Certificate.SubjectKeyId,
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, ca.Certificate, csr.PublicKey, ca.PrivateKey)
	if err != nil {
		return nil, fmt.Errorf("sign certificate: %w", err)
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, fmt.Errorf("parse certificate: %w", err)
	}

	return cert, nil
}

// GenerateControllerOperationalCert creates an operational certificate for a controller.
// This is signed by the Zone CA and used for mutual TLS authentication with devices.
// Unlike device certificates (which are issued via CSR during commissioning),
// controller certificates are generated directly by the controller that owns the Zone CA.
func GenerateControllerOperationalCert(ca *ZoneCA, controllerID string) (*OperationalCert, error) {
	if ca == nil || ca.PrivateKey == nil || ca.Certificate == nil {
		return nil, fmt.Errorf("valid Zone CA is required")
	}
	if controllerID == "" {
		return nil, fmt.Errorf("controller ID is required")
	}

	// Generate a fresh key pair for this certificate
	keyPair, err := GenerateKeyPair()
	if err != nil {
		return nil, fmt.Errorf("generate key pair: %w", err)
	}

	ski, err := ComputeSKI(keyPair.PublicKey)
	if err != nil {
		return nil, fmt.Errorf("compute SKI: %w", err)
	}

	serialNumber, err := generateSerialNumber()
	if err != nil {
		return nil, fmt.Errorf("generate serial number: %w", err)
	}

	now := time.Now()
	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   controllerID,
			Organization: []string{"MASH Controller"},
			OrganizationalUnit: []string{
				ca.ZoneType.String(),
				ca.ZoneID,
			},
		},
		NotBefore:             now,
		NotAfter:              now.Add(OperationalCertValidity),
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		IsCA:                  false,
		SubjectKeyId:          ski,
		AuthorityKeyId:        ca.Certificate.SubjectKeyId,
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, ca.Certificate, keyPair.PublicKey, ca.PrivateKey)
	if err != nil {
		return nil, fmt.Errorf("create certificate: %w", err)
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, fmt.Errorf("parse certificate: %w", err)
	}

	return &OperationalCert{
		Certificate: cert,
		PrivateKey:  keyPair.PrivateKey,
		ZoneID:      ca.ZoneID,
		ZoneType:    ca.ZoneType,
		ZoneCACert:  ca.Certificate,
	}, nil
}

// GenerateDeviceAttestationCert creates a device attestation certificate.
// This is typically done at manufacturing time and proves device identity.
// If manufacturerCA is nil, the certificate will be self-signed.
func GenerateDeviceAttestationCert(keyPair *KeyPair, identity *DeviceIdentity, manufacturerCA *ZoneCA) (*x509.Certificate, error) {
	if keyPair == nil || keyPair.PrivateKey == nil {
		return nil, fmt.Errorf("key pair is required")
	}
	if identity == nil {
		return nil, fmt.Errorf("device identity is required")
	}

	ski, err := ComputeSKI(keyPair.PublicKey)
	if err != nil {
		return nil, fmt.Errorf("compute SKI: %w", err)
	}

	serialNumber, err := generateSerialNumber()
	if err != nil {
		return nil, fmt.Errorf("generate serial number: %w", err)
	}

	now := time.Now()
	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   identity.DeviceID,
			Organization: []string{fmt.Sprintf("Vendor-%d", identity.VendorID)},
			OrganizationalUnit: []string{
				fmt.Sprintf("Product-%d", identity.ProductID),
			},
		},
		NotBefore:             now,
		NotAfter:              now.Add(DeviceAttestationValidity),
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		IsCA:                  false,
		SubjectKeyId:          ski,
	}

	if identity.SerialNumber != "" {
		template.Subject.SerialNumber = identity.SerialNumber
	}

	var signerCert *x509.Certificate
	var signerKey *ecdsa.PrivateKey

	if manufacturerCA != nil {
		signerCert = manufacturerCA.Certificate
		signerKey = manufacturerCA.PrivateKey
		template.AuthorityKeyId = manufacturerCA.Certificate.SubjectKeyId
	} else {
		// Self-signed
		signerCert = template
		signerKey = keyPair.PrivateKey
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, signerCert, keyPair.PublicKey, signerKey)
	if err != nil {
		return nil, fmt.Errorf("create certificate: %w", err)
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, fmt.Errorf("parse certificate: %w", err)
	}

	return cert, nil
}

// generateSerialNumber generates a random serial number for certificates.
func generateSerialNumber() (*big.Int, error) {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128) // 128 bits
	return rand.Int(rand.Reader, serialNumberLimit)
}
