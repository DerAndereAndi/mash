// Code generated by mash-featgen. DO NOT EDIT.

package features

import (
	"context"

	"github.com/mash-protocol/mash-go/pkg/model"
	"github.com/mash-protocol/mash-go/pkg/wire"
)

// Signals attribute IDs.
const (
	SignalsAttrSignalSource    uint16 = 1
	SignalsAttrStartTime       uint16 = 2
	SignalsAttrValidUntil      uint16 = 3
	SignalsAttrPriceSlots      uint16 = 10
	SignalsAttrConstraintSlots uint16 = 20
	SignalsAttrForecastSlots   uint16 = 30
)

// SignalsFeatureRevision is the current revision of the Signals feature.
const SignalsFeatureRevision uint16 = 1

// SignalSource represents origin of the signal data.
type SignalSource uint8

const (
	// SignalSourceGrid grid operator.
	SignalSourceGrid SignalSource = 0x00
	// SignalSourceEnergySupplier energy supplier / utility.
	SignalSourceEnergySupplier SignalSource = 0x01
	// SignalSourceAggregator aggregator / VPP operator.
	SignalSourceAggregator SignalSource = 0x02
	// SignalSourceLocalEms local energy management system.
	SignalSourceLocalEms SignalSource = 0x03
)

// String returns the signalSource name.
func (v SignalSource) String() string {
	switch v {
	case SignalSourceGrid:
		return "GRID"
	case SignalSourceEnergySupplier:
		return "ENERGY_SUPPLIER"
	case SignalSourceAggregator:
		return "AGGREGATOR"
	case SignalSourceLocalEms:
		return "LOCAL_EMS"
	default:
		return "UNKNOWN"
	}
}

// PriceSlot represents an item in the priceSlots array.
type PriceSlot struct {
	Duration         uint32
	Price            int32
	PriceLevel       uint8
	RenewablePercent uint8
	Co2Intensity     uint16
}

// ConstraintSlot represents an item in the constraintSlots array.
type ConstraintSlot struct {
	Duration       uint32
	ConsumptionMax int64
	ConsumptionMin int64
	ProductionMax  int64
	ProductionMin  int64
}

// ForecastSlot represents an item in the forecastSlots array.
type ForecastSlot struct {
	Duration       uint32
	ForecastPower  int64
	ForecastEnergy int64
}

// Signals wraps a Feature with Signals-specific functionality.
// Time-slotted price, constraint, and forecast signals from controller to device.
type Signals struct {
	*model.Feature
	onSendPriceSignal      func(ctx context.Context, req SendPriceSignalRequest) error
	onSendConstraintSignal func(ctx context.Context, req SendConstraintSignalRequest) error
	onSendForecastSignal   func(ctx context.Context, req SendForecastSignalRequest) error
	onClearSignals         func(ctx context.Context, req ClearSignalsRequest) (ClearSignalsResponse, error)
}

// NewSignals creates a new Signals feature.
func NewSignals() *Signals {
	f := model.NewFeature(model.FeatureSignals, SignalsFeatureRevision)

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          SignalsAttrSignalSource,
		Name:        "signalSource",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Who sent the currently active signal",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          SignalsAttrStartTime,
		Name:        "startTime",
		Type:        model.DataTypeUint64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Unix timestamp for first slot",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          SignalsAttrValidUntil,
		Name:        "validUntil",
		Type:        model.DataTypeUint64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "When signal expires (Unix timestamp)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          SignalsAttrPriceSlots,
		Name:        "priceSlots",
		Type:        model.DataTypeArray,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Active price schedule slots",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          SignalsAttrConstraintSlots,
		Name:        "constraintSlots",
		Type:        model.DataTypeArray,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Active power constraint slots",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          SignalsAttrForecastSlots,
		Name:        "forecastSlots",
		Type:        model.DataTypeArray,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Active forecast slots",
	}))

	s := &Signals{Feature: f}
	s.addCommands()

	return s
}

// SignalSource returns the who sent the currently active signal.
func (s *Signals) SignalSource() (SignalSource, bool) {
	val, err := s.ReadAttribute(SignalsAttrSignalSource)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint8); ok {
		return SignalSource(v), true
	}
	return 0, false
}

// StartTime returns the unix timestamp for first slot.
func (s *Signals) StartTime() (uint64, bool) {
	val, err := s.ReadAttribute(SignalsAttrStartTime)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint64); ok {
		return v, true
	}
	return 0, false
}

// ValidUntil returns the when signal expires (Unix timestamp).
func (s *Signals) ValidUntil() (uint64, bool) {
	val, err := s.ReadAttribute(SignalsAttrValidUntil)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint64); ok {
		return v, true
	}
	return 0, false
}

// PriceSlots returns the active price schedule slots.
func (s *Signals) PriceSlots() ([]PriceSlot, bool) {
	val, err := s.ReadAttribute(SignalsAttrPriceSlots)
	if err != nil || val == nil {
		return nil, false
	}
	raw, ok := val.([]any)
	if !ok {
		return nil, false
	}
	result := make([]PriceSlot, 0, len(raw))
	for _, item := range raw {
		m, ok := item.(map[string]any)
		if !ok {
			continue
		}
		entry := PriceSlot{}
		if v, ok := m["duration"]; ok {
			if n, ok := v.(uint32); ok {
				entry.Duration = n
			}
		}
		if v, ok := m["price"]; ok {
			if n, ok := v.(int32); ok {
				entry.Price = n
			}
		}
		if v, ok := m["priceLevel"]; ok {
			if n, ok := v.(uint8); ok {
				entry.PriceLevel = n
			}
		}
		if v, ok := m["renewablePercent"]; ok {
			if n, ok := v.(uint8); ok {
				entry.RenewablePercent = n
			}
		}
		if v, ok := m["co2Intensity"]; ok {
			if n, ok := v.(uint16); ok {
				entry.Co2Intensity = n
			}
		}
		result = append(result, entry)
	}
	return result, true
}

// ConstraintSlots returns the active power constraint slots.
func (s *Signals) ConstraintSlots() ([]ConstraintSlot, bool) {
	val, err := s.ReadAttribute(SignalsAttrConstraintSlots)
	if err != nil || val == nil {
		return nil, false
	}
	raw, ok := val.([]any)
	if !ok {
		return nil, false
	}
	result := make([]ConstraintSlot, 0, len(raw))
	for _, item := range raw {
		m, ok := item.(map[string]any)
		if !ok {
			continue
		}
		entry := ConstraintSlot{}
		if v, ok := m["duration"]; ok {
			if n, ok := v.(uint32); ok {
				entry.Duration = n
			}
		}
		if v, ok := m["consumptionMax"]; ok {
			if n, ok := v.(int64); ok {
				entry.ConsumptionMax = n
			}
		}
		if v, ok := m["consumptionMin"]; ok {
			if n, ok := v.(int64); ok {
				entry.ConsumptionMin = n
			}
		}
		if v, ok := m["productionMax"]; ok {
			if n, ok := v.(int64); ok {
				entry.ProductionMax = n
			}
		}
		if v, ok := m["productionMin"]; ok {
			if n, ok := v.(int64); ok {
				entry.ProductionMin = n
			}
		}
		result = append(result, entry)
	}
	return result, true
}

// ForecastSlots returns the active forecast slots.
func (s *Signals) ForecastSlots() ([]ForecastSlot, bool) {
	val, err := s.ReadAttribute(SignalsAttrForecastSlots)
	if err != nil || val == nil {
		return nil, false
	}
	raw, ok := val.([]any)
	if !ok {
		return nil, false
	}
	result := make([]ForecastSlot, 0, len(raw))
	for _, item := range raw {
		m, ok := item.(map[string]any)
		if !ok {
			continue
		}
		entry := ForecastSlot{}
		if v, ok := m["duration"]; ok {
			if n, ok := v.(uint32); ok {
				entry.Duration = n
			}
		}
		if v, ok := m["forecastPower"]; ok {
			if n, ok := v.(int64); ok {
				entry.ForecastPower = n
			}
		}
		if v, ok := m["forecastEnergy"]; ok {
			if n, ok := v.(int64); ok {
				entry.ForecastEnergy = n
			}
		}
		result = append(result, entry)
	}
	return result, true
}

// SetSignalSource sets the who sent the currently active signal.
func (s *Signals) SetSignalSource(signalSource SignalSource) error {
	attr, err := s.GetAttribute(SignalsAttrSignalSource)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(signalSource))
}

// ClearSignalSource clears the who sent the currently active signal.
func (s *Signals) ClearSignalSource() error {
	attr, err := s.GetAttribute(SignalsAttrSignalSource)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetSignalSourcePtr sets or clears the who sent the currently active signal from a pointer.
func (s *Signals) SetSignalSourcePtr(v *SignalSource) error {
	if v == nil {
		return s.ClearSignalSource()
	}
	return s.SetSignalSource(*v)
}

// SetStartTime sets the unix timestamp for first slot.
func (s *Signals) SetStartTime(startTime uint64) error {
	attr, err := s.GetAttribute(SignalsAttrStartTime)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(startTime)
}

// ClearStartTime clears the unix timestamp for first slot.
func (s *Signals) ClearStartTime() error {
	attr, err := s.GetAttribute(SignalsAttrStartTime)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetStartTimePtr sets or clears the unix timestamp for first slot from a pointer.
func (s *Signals) SetStartTimePtr(v *uint64) error {
	if v == nil {
		return s.ClearStartTime()
	}
	return s.SetStartTime(*v)
}

// SetValidUntil sets the when signal expires (Unix timestamp).
func (s *Signals) SetValidUntil(validUntil uint64) error {
	attr, err := s.GetAttribute(SignalsAttrValidUntil)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(validUntil)
}

// ClearValidUntil clears the when signal expires (Unix timestamp).
func (s *Signals) ClearValidUntil() error {
	attr, err := s.GetAttribute(SignalsAttrValidUntil)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetValidUntilPtr sets or clears the when signal expires (Unix timestamp) from a pointer.
func (s *Signals) SetValidUntilPtr(v *uint64) error {
	if v == nil {
		return s.ClearValidUntil()
	}
	return s.SetValidUntil(*v)
}

// SetPriceSlots sets the active price schedule slots.
func (s *Signals) SetPriceSlots(priceSlots []PriceSlot) error {
	attr, err := s.GetAttribute(SignalsAttrPriceSlots)
	if err != nil {
		return err
	}
	if priceSlots == nil {
		return attr.SetValueInternal(nil)
	}
	data := make([]map[string]any, len(priceSlots))
	for i, item := range priceSlots {
		data[i] = map[string]any{
			"duration":         item.Duration,
			"price":            item.Price,
			"priceLevel":       item.PriceLevel,
			"renewablePercent": item.RenewablePercent,
			"co2Intensity":     item.Co2Intensity,
		}
	}
	return attr.SetValueInternal(data)
}

// ClearPriceSlots clears the active price schedule slots.
func (s *Signals) ClearPriceSlots() error {
	attr, err := s.GetAttribute(SignalsAttrPriceSlots)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetConstraintSlots sets the active power constraint slots.
func (s *Signals) SetConstraintSlots(constraintSlots []ConstraintSlot) error {
	attr, err := s.GetAttribute(SignalsAttrConstraintSlots)
	if err != nil {
		return err
	}
	if constraintSlots == nil {
		return attr.SetValueInternal(nil)
	}
	data := make([]map[string]any, len(constraintSlots))
	for i, item := range constraintSlots {
		data[i] = map[string]any{
			"duration":       item.Duration,
			"consumptionMax": item.ConsumptionMax,
			"consumptionMin": item.ConsumptionMin,
			"productionMax":  item.ProductionMax,
			"productionMin":  item.ProductionMin,
		}
	}
	return attr.SetValueInternal(data)
}

// ClearConstraintSlots clears the active power constraint slots.
func (s *Signals) ClearConstraintSlots() error {
	attr, err := s.GetAttribute(SignalsAttrConstraintSlots)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetForecastSlots sets the active forecast slots.
func (s *Signals) SetForecastSlots(forecastSlots []ForecastSlot) error {
	attr, err := s.GetAttribute(SignalsAttrForecastSlots)
	if err != nil {
		return err
	}
	if forecastSlots == nil {
		return attr.SetValueInternal(nil)
	}
	data := make([]map[string]any, len(forecastSlots))
	for i, item := range forecastSlots {
		data[i] = map[string]any{
			"duration":       item.Duration,
			"forecastPower":  item.ForecastPower,
			"forecastEnergy": item.ForecastEnergy,
		}
	}
	return attr.SetValueInternal(data)
}

// ClearForecastSlots clears the active forecast slots.
func (s *Signals) ClearForecastSlots() error {
	attr, err := s.GetAttribute(SignalsAttrForecastSlots)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// Signals command IDs.
const (
	SignalsCmdSendPriceSignal      uint8 = 1
	SignalsCmdSendConstraintSignal uint8 = 2
	SignalsCmdSendForecastSignal   uint8 = 3
	SignalsCmdClearSignals         uint8 = 4
)

// SendPriceSignalRequest represents the sendPriceSignal command parameters.
type SendPriceSignalRequest struct {
	Source     SignalSource
	StartTime  uint64
	ValidUntil *uint64
	Slots      []any
}

// SendConstraintSignalRequest represents the sendConstraintSignal command parameters.
type SendConstraintSignalRequest struct {
	Source     SignalSource
	StartTime  uint64
	ValidUntil *uint64
	Slots      []any
}

// SendForecastSignalRequest represents the sendForecastSignal command parameters.
type SendForecastSignalRequest struct {
	Source     SignalSource
	StartTime  uint64
	ValidUntil *uint64
	Slots      []any
}

// ClearSignalsRequest represents the clearSignals command parameters.
type ClearSignalsRequest struct {
	SignalType *string
}

// ClearSignalsResponse represents the clearSignals command response.
type ClearSignalsResponse struct {
	Cleared uint8
}

// addCommands adds the Signals commands.
func (s *Signals) addCommands() {
	s.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          SignalsCmdSendPriceSignal,
		Name:        "sendPriceSignal",
		Description: "Send a price signal schedule to the device",
		Parameters: []model.ParameterMetadata{
			{Name: "source", Type: model.DataTypeUint8, Required: true},
			{Name: "startTime", Type: model.DataTypeUint64, Required: true},
			{Name: "validUntil", Type: model.DataTypeUint64, Required: false},
			{Name: "slots", Type: model.DataTypeArray, Required: true},
		},
	}, s.handleSendPriceSignal))

	s.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          SignalsCmdSendConstraintSignal,
		Name:        "sendConstraintSignal",
		Description: "Send a power constraint signal to the device",
		Parameters: []model.ParameterMetadata{
			{Name: "source", Type: model.DataTypeUint8, Required: true},
			{Name: "startTime", Type: model.DataTypeUint64, Required: true},
			{Name: "validUntil", Type: model.DataTypeUint64, Required: false},
			{Name: "slots", Type: model.DataTypeArray, Required: true},
		},
	}, s.handleSendConstraintSignal))

	s.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          SignalsCmdSendForecastSignal,
		Name:        "sendForecastSignal",
		Description: "Send a power forecast signal to the device",
		Parameters: []model.ParameterMetadata{
			{Name: "source", Type: model.DataTypeUint8, Required: true},
			{Name: "startTime", Type: model.DataTypeUint64, Required: true},
			{Name: "validUntil", Type: model.DataTypeUint64, Required: false},
			{Name: "slots", Type: model.DataTypeArray, Required: true},
		},
	}, s.handleSendForecastSignal))

	s.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          SignalsCmdClearSignals,
		Name:        "clearSignals",
		Description: "Clear active signals",
		Parameters: []model.ParameterMetadata{
			{Name: "signalType", Type: model.DataTypeString, Required: false},
		},
	}, s.handleClearSignals))

}

func (s *Signals) handleSendPriceSignal(ctx context.Context, params map[string]any) (map[string]any, error) {
	if s.onSendPriceSignal == nil {
		return map[string]any{"success": false}, nil
	}

	req := SendPriceSignalRequest{}
	if raw, exists := params["source"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Source = SignalSource(v)
		}
	}
	if raw, exists := params["startTime"]; exists {
		if v, ok := raw.(uint64); ok {
			req.StartTime = v
		}
	}
	if raw, exists := params["validUntil"]; exists {
		if v, ok := raw.(uint64); ok {
			req.ValidUntil = &v
		}
	}
	if raw, exists := params["slots"]; exists {
		if v, ok := raw.([]any); ok {
			req.Slots = v
		}
	}

	err := s.onSendPriceSignal(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (s *Signals) handleSendConstraintSignal(ctx context.Context, params map[string]any) (map[string]any, error) {
	if s.onSendConstraintSignal == nil {
		return map[string]any{"success": false}, nil
	}

	req := SendConstraintSignalRequest{}
	if raw, exists := params["source"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Source = SignalSource(v)
		}
	}
	if raw, exists := params["startTime"]; exists {
		if v, ok := raw.(uint64); ok {
			req.StartTime = v
		}
	}
	if raw, exists := params["validUntil"]; exists {
		if v, ok := raw.(uint64); ok {
			req.ValidUntil = &v
		}
	}
	if raw, exists := params["slots"]; exists {
		if v, ok := raw.([]any); ok {
			req.Slots = v
		}
	}

	err := s.onSendConstraintSignal(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (s *Signals) handleSendForecastSignal(ctx context.Context, params map[string]any) (map[string]any, error) {
	if s.onSendForecastSignal == nil {
		return map[string]any{"success": false}, nil
	}

	req := SendForecastSignalRequest{}
	if raw, exists := params["source"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Source = SignalSource(v)
		}
	}
	if raw, exists := params["startTime"]; exists {
		if v, ok := raw.(uint64); ok {
			req.StartTime = v
		}
	}
	if raw, exists := params["validUntil"]; exists {
		if v, ok := raw.(uint64); ok {
			req.ValidUntil = &v
		}
	}
	if raw, exists := params["slots"]; exists {
		if v, ok := raw.([]any); ok {
			req.Slots = v
		}
	}

	err := s.onSendForecastSignal(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (s *Signals) handleClearSignals(ctx context.Context, params map[string]any) (map[string]any, error) {
	if s.onClearSignals == nil {
		return map[string]any{"success": false}, nil
	}

	req := ClearSignalsRequest{}
	if raw, exists := params["signalType"]; exists {
		if v, ok := raw.(string); ok {
			req.SignalType = &v
		}
	}

	resp, err := s.onClearSignals(ctx, req)
	if err != nil {
		return nil, err
	}

	result := make(map[string]any)
	result["cleared"] = resp.Cleared
	return result, nil
}

// OnSendPriceSignal sets the handler for sendPriceSignal command.
func (s *Signals) OnSendPriceSignal(handler func(ctx context.Context, req SendPriceSignalRequest) error) {
	s.onSendPriceSignal = handler
}

// OnSendConstraintSignal sets the handler for sendConstraintSignal command.
func (s *Signals) OnSendConstraintSignal(handler func(ctx context.Context, req SendConstraintSignalRequest) error) {
	s.onSendConstraintSignal = handler
}

// OnSendForecastSignal sets the handler for sendForecastSignal command.
func (s *Signals) OnSendForecastSignal(handler func(ctx context.Context, req SendForecastSignalRequest) error) {
	s.onSendForecastSignal = handler
}

// OnClearSignals sets the handler for clearSignals command.
func (s *Signals) OnClearSignals(handler func(ctx context.Context, req ClearSignalsRequest) (ClearSignalsResponse, error)) {
	s.onClearSignals = handler
}
