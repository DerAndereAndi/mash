// Code generated by mash-featgen. DO NOT EDIT.

package features

import "github.com/mash-protocol/mash-go/pkg/model"

// Electrical attribute IDs.
const (
	ElectricalAttrPhaseCount            uint16 = 1
	ElectricalAttrPhaseMapping          uint16 = 2
	ElectricalAttrNominalVoltage        uint16 = 3
	ElectricalAttrNominalFrequency      uint16 = 4
	ElectricalAttrSupportedDirections   uint16 = 5
	ElectricalAttrNominalMaxConsumption uint16 = 10
	ElectricalAttrNominalMaxProduction  uint16 = 11
	ElectricalAttrNominalMinPower       uint16 = 12
	ElectricalAttrMaxCurrentPerPhase    uint16 = 13
	ElectricalAttrMinCurrentPerPhase    uint16 = 14
	ElectricalAttrSupportsAsymmetric    uint16 = 15
	ElectricalAttrEnergyCapacity        uint16 = 20
)

// ElectricalFeatureRevision is the current revision of the Electrical feature.
const ElectricalFeatureRevision uint16 = 1

// Electrical wraps a Feature with Electrical-specific functionality.
// Electrical characteristics and capability envelope of an endpoint.
type Electrical struct {
	*model.Feature
}

// NewElectrical creates a new Electrical feature.
func NewElectrical() *Electrical {
	f := model.NewFeature(model.FeatureElectrical, ElectricalFeatureRevision)

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrPhaseCount,
		Name:        "phaseCount",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(1),
		MinValue:    uint8(1),
		MaxValue:    uint8(3),
		Description: "Number of phases (1, 2, or 3)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrPhaseMapping,
		Name:        "phaseMapping",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Description: "Device phase to grid phase mapping",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrNominalVoltage,
		Name:        "nominalVoltage",
		Type:        model.DataTypeUint16,
		Access:      model.AccessReadOnly,
		Default:     uint16(230),
		Unit:        "V",
		Description: "Nominal voltage",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrNominalFrequency,
		Name:        "nominalFrequency",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(50),
		Unit:        "Hz",
		Description: "Nominal frequency",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrSupportedDirections,
		Name:        "supportedDirections",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(DirectionConsumption),
		Description: "Power flow direction capability",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrNominalMaxConsumption,
		Name:        "nominalMaxConsumption",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Default:     int64(0),
		Unit:        "mW",
		Description: "Maximum consumption power",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrNominalMaxProduction,
		Name:        "nominalMaxProduction",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Default:     int64(0),
		Unit:        "mW",
		Description: "Maximum production power (0 if N/A)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrNominalMinPower,
		Name:        "nominalMinPower",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Default:     int64(0),
		Unit:        "mW",
		Description: "Minimum operating point",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrMaxCurrentPerPhase,
		Name:        "maxCurrentPerPhase",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Default:     int64(0),
		Unit:        "mA",
		Description: "Maximum current per phase",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrMinCurrentPerPhase,
		Name:        "minCurrentPerPhase",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Default:     int64(0),
		Unit:        "mA",
		Description: "Minimum current per phase",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrSupportsAsymmetric,
		Name:        "supportsAsymmetric",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(AsymmetricSupportNone),
		Description: "Per-phase asymmetric control support",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          ElectricalAttrEnergyCapacity,
		Name:        "energyCapacity",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Default:     int64(0),
		Unit:        "mWh",
		Description: "Battery/storage capacity (0 if N/A)",
	}))

	return &Electrical{Feature: f}
}

// PhaseCount returns the number of phases (1, 2, or 3).
func (e *Electrical) PhaseCount() uint8 {
	val, _ := e.ReadAttribute(ElectricalAttrPhaseCount)
	if v, ok := val.(uint8); ok {
		return v
	}
	return uint8(1)
}

// PhaseMapping returns the device phase to grid phase mapping.
func (e *Electrical) PhaseMapping() (map[Phase]GridPhase, bool) {
	val, err := e.ReadAttribute(ElectricalAttrPhaseMapping)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]GridPhase); ok {
		return v, true
	}
	return nil, false
}

// NominalVoltage returns the nominal voltage.
func (e *Electrical) NominalVoltage() uint16 {
	val, _ := e.ReadAttribute(ElectricalAttrNominalVoltage)
	if v, ok := val.(uint16); ok {
		return v
	}
	return uint16(230)
}

// NominalFrequency returns the nominal frequency.
func (e *Electrical) NominalFrequency() uint8 {
	val, _ := e.ReadAttribute(ElectricalAttrNominalFrequency)
	if v, ok := val.(uint8); ok {
		return v
	}
	return uint8(50)
}

// SupportedDirections returns the power flow direction capability.
func (e *Electrical) SupportedDirections() Direction {
	val, _ := e.ReadAttribute(ElectricalAttrSupportedDirections)
	if v, ok := val.(uint8); ok {
		return Direction(v)
	}
	return DirectionConsumption
}

// NominalMaxConsumption returns the maximum consumption power.
func (e *Electrical) NominalMaxConsumption() int64 {
	val, _ := e.ReadAttribute(ElectricalAttrNominalMaxConsumption)
	if v, ok := val.(int64); ok {
		return v
	}
	return int64(0)
}

// NominalMaxProduction returns the maximum production power (0 if N/A).
func (e *Electrical) NominalMaxProduction() int64 {
	val, _ := e.ReadAttribute(ElectricalAttrNominalMaxProduction)
	if v, ok := val.(int64); ok {
		return v
	}
	return int64(0)
}

// NominalMinPower returns the minimum operating point.
func (e *Electrical) NominalMinPower() int64 {
	val, _ := e.ReadAttribute(ElectricalAttrNominalMinPower)
	if v, ok := val.(int64); ok {
		return v
	}
	return int64(0)
}

// MaxCurrentPerPhase returns the maximum current per phase.
func (e *Electrical) MaxCurrentPerPhase() int64 {
	val, _ := e.ReadAttribute(ElectricalAttrMaxCurrentPerPhase)
	if v, ok := val.(int64); ok {
		return v
	}
	return int64(0)
}

// MinCurrentPerPhase returns the minimum current per phase.
func (e *Electrical) MinCurrentPerPhase() int64 {
	val, _ := e.ReadAttribute(ElectricalAttrMinCurrentPerPhase)
	if v, ok := val.(int64); ok {
		return v
	}
	return int64(0)
}

// SupportsAsymmetric returns the per-phase asymmetric control support.
func (e *Electrical) SupportsAsymmetric() AsymmetricSupport {
	val, _ := e.ReadAttribute(ElectricalAttrSupportsAsymmetric)
	if v, ok := val.(uint8); ok {
		return AsymmetricSupport(v)
	}
	return AsymmetricSupportNone
}

// EnergyCapacity returns the battery/storage capacity (0 if N/A).
func (e *Electrical) EnergyCapacity() int64 {
	val, _ := e.ReadAttribute(ElectricalAttrEnergyCapacity)
	if v, ok := val.(int64); ok {
		return v
	}
	return int64(0)
}

// SetPhaseCount sets the number of phases (1, 2, or 3).
func (e *Electrical) SetPhaseCount(phaseCount uint8) error {
	attr, err := e.GetAttribute(ElectricalAttrPhaseCount)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(phaseCount)
}

// SetPhaseMapping sets the device phase to grid phase mapping.
func (e *Electrical) SetPhaseMapping(phaseMapping map[Phase]GridPhase) error {
	attr, err := e.GetAttribute(ElectricalAttrPhaseMapping)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(phaseMapping)
}

// SetNominalVoltage sets the nominal voltage.
func (e *Electrical) SetNominalVoltage(nominalVoltage uint16) error {
	attr, err := e.GetAttribute(ElectricalAttrNominalVoltage)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nominalVoltage)
}

// SetNominalFrequency sets the nominal frequency.
func (e *Electrical) SetNominalFrequency(nominalFrequency uint8) error {
	attr, err := e.GetAttribute(ElectricalAttrNominalFrequency)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nominalFrequency)
}

// SetSupportedDirections sets the power flow direction capability.
func (e *Electrical) SetSupportedDirections(supportedDirections Direction) error {
	attr, err := e.GetAttribute(ElectricalAttrSupportedDirections)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(supportedDirections))
}

// SetNominalMaxConsumption sets the maximum consumption power.
func (e *Electrical) SetNominalMaxConsumption(nominalMaxConsumption int64) error {
	attr, err := e.GetAttribute(ElectricalAttrNominalMaxConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nominalMaxConsumption)
}

// SetNominalMaxProduction sets the maximum production power (0 if N/A).
func (e *Electrical) SetNominalMaxProduction(nominalMaxProduction int64) error {
	attr, err := e.GetAttribute(ElectricalAttrNominalMaxProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nominalMaxProduction)
}

// SetNominalMinPower sets the minimum operating point.
func (e *Electrical) SetNominalMinPower(nominalMinPower int64) error {
	attr, err := e.GetAttribute(ElectricalAttrNominalMinPower)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nominalMinPower)
}

// SetMaxCurrentPerPhase sets the maximum current per phase.
func (e *Electrical) SetMaxCurrentPerPhase(maxCurrentPerPhase int64) error {
	attr, err := e.GetAttribute(ElectricalAttrMaxCurrentPerPhase)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(maxCurrentPerPhase)
}

// SetMinCurrentPerPhase sets the minimum current per phase.
func (e *Electrical) SetMinCurrentPerPhase(minCurrentPerPhase int64) error {
	attr, err := e.GetAttribute(ElectricalAttrMinCurrentPerPhase)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(minCurrentPerPhase)
}

// SetSupportsAsymmetric sets the per-phase asymmetric control support.
func (e *Electrical) SetSupportsAsymmetric(supportsAsymmetric AsymmetricSupport) error {
	attr, err := e.GetAttribute(ElectricalAttrSupportsAsymmetric)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(supportsAsymmetric))
}

// SetEnergyCapacity sets the battery/storage capacity (0 if N/A).
func (e *Electrical) SetEnergyCapacity(energyCapacity int64) error {
	attr, err := e.GetAttribute(ElectricalAttrEnergyCapacity)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(energyCapacity)
}
