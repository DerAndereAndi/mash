// Code generated by mash-featgen. DO NOT EDIT.

package features

import (
	"context"

	"github.com/mash-protocol/mash-go/pkg/model"
	"github.com/mash-protocol/mash-go/pkg/wire"
)

// EnergyControl attribute IDs.
const (
	EnergyControlAttrDeviceType                           uint16 = 1
	EnergyControlAttrControlState                         uint16 = 2
	EnergyControlAttrOptOutState                          uint16 = 3
	EnergyControlAttrAcceptsLimits                        uint16 = 10
	EnergyControlAttrAcceptsCurrentLimits                 uint16 = 11
	EnergyControlAttrAcceptsSetpoints                     uint16 = 12
	EnergyControlAttrAcceptsCurrentSetpoints              uint16 = 13
	EnergyControlAttrIsPausable                           uint16 = 14
	EnergyControlAttrIsShiftable                          uint16 = 15
	EnergyControlAttrIsStoppable                          uint16 = 16
	EnergyControlAttrEffectiveConsumptionLimit            uint16 = 20
	EnergyControlAttrMyConsumptionLimit                   uint16 = 21
	EnergyControlAttrEffectiveProductionLimit             uint16 = 22
	EnergyControlAttrMyProductionLimit                    uint16 = 23
	EnergyControlAttrEffectiveCurrentLimitsConsumption    uint16 = 30
	EnergyControlAttrMyCurrentLimitsConsumption           uint16 = 31
	EnergyControlAttrEffectiveCurrentLimitsProduction     uint16 = 32
	EnergyControlAttrMyCurrentLimitsProduction            uint16 = 33
	EnergyControlAttrEffectiveConsumptionSetpoint         uint16 = 40
	EnergyControlAttrMyConsumptionSetpoint                uint16 = 41
	EnergyControlAttrEffectiveProductionSetpoint          uint16 = 42
	EnergyControlAttrMyProductionSetpoint                 uint16 = 43
	EnergyControlAttrEffectiveCurrentSetpointsConsumption uint16 = 50
	EnergyControlAttrMyCurrentSetpointsConsumption        uint16 = 51
	EnergyControlAttrEffectiveCurrentSetpointsProduction  uint16 = 52
	EnergyControlAttrMyCurrentSetpointsProduction         uint16 = 53
	EnergyControlAttrFailsafeConsumptionLimit             uint16 = 70
	EnergyControlAttrFailsafeProductionLimit              uint16 = 71
	EnergyControlAttrFailsafeDuration                     uint16 = 72
	EnergyControlAttrContractualConsumptionMax            uint16 = 73
	EnergyControlAttrContractualProductionMax             uint16 = 74
	EnergyControlAttrOverrideReason                       uint16 = 75
	EnergyControlAttrOverrideDirection                    uint16 = 76
	EnergyControlAttrProcessState                         uint16 = 80
	EnergyControlAttrOptionalProcess                      uint16 = 81
)

// EnergyControlFeatureRevision is the current revision of the EnergyControl feature.
const EnergyControlFeatureRevision uint16 = 1

// DeviceType represents type of controllable device.
type DeviceType uint8

const (
	// DeviceTypeEVSE electric vehicle supply equipment.
	DeviceTypeEVSE DeviceType = 0x00
	// DeviceTypeHeatPump heat pump.
	DeviceTypeHeatPump DeviceType = 0x01
	// DeviceTypeWaterHeater water heater.
	DeviceTypeWaterHeater DeviceType = 0x02
	// DeviceTypeBattery battery storage.
	DeviceTypeBattery DeviceType = 0x03
	// DeviceTypeInverter solar/hybrid inverter.
	DeviceTypeInverter DeviceType = 0x04
	// DeviceTypeFlexibleLoad generic flexible load.
	DeviceTypeFlexibleLoad DeviceType = 0x05
	// DeviceTypeOther other device type.
	DeviceTypeOther DeviceType = 0xFF
)

// String returns the deviceType name.
func (v DeviceType) String() string {
	switch v {
	case DeviceTypeEVSE:
		return "EVSE"
	case DeviceTypeHeatPump:
		return "HEAT_PUMP"
	case DeviceTypeWaterHeater:
		return "WATER_HEATER"
	case DeviceTypeBattery:
		return "BATTERY"
	case DeviceTypeInverter:
		return "INVERTER"
	case DeviceTypeFlexibleLoad:
		return "FLEXIBLE_LOAD"
	case DeviceTypeOther:
		return "OTHER"
	default:
		return "UNKNOWN"
	}
}

// ControlState represents control relationship state.
type ControlState uint8

const (
	// ControlStateAutonomous not under external control.
	ControlStateAutonomous ControlState = 0x00
	// ControlStateControlled under controller authority, no active limit.
	ControlStateControlled ControlState = 0x01
	// ControlStateLimited active power limit being applied.
	ControlStateLimited ControlState = 0x02
	// ControlStateFailsafe connection lost, using failsafe limits.
	ControlStateFailsafe ControlState = 0x03
	// ControlStateOverride device overriding limits (safety/legal).
	ControlStateOverride ControlState = 0x04
)

// String returns the controlState name.
func (v ControlState) String() string {
	switch v {
	case ControlStateAutonomous:
		return "AUTONOMOUS"
	case ControlStateControlled:
		return "CONTROLLED"
	case ControlStateLimited:
		return "LIMITED"
	case ControlStateFailsafe:
		return "FAILSAFE"
	case ControlStateOverride:
		return "OVERRIDE"
	default:
		return "UNKNOWN"
	}
}

// ProcessState represents optional task lifecycle state.
type ProcessState uint8

const (
	ProcessStateNone      ProcessState = 0x00
	ProcessStateAvailable ProcessState = 0x01
	ProcessStateScheduled ProcessState = 0x02
	ProcessStateRunning   ProcessState = 0x03
	ProcessStatePaused    ProcessState = 0x04
	ProcessStateCompleted ProcessState = 0x05
	ProcessStateAborted   ProcessState = 0x06
)

// String returns the processState name.
func (v ProcessState) String() string {
	switch v {
	case ProcessStateNone:
		return "NONE"
	case ProcessStateAvailable:
		return "AVAILABLE"
	case ProcessStateScheduled:
		return "SCHEDULED"
	case ProcessStateRunning:
		return "RUNNING"
	case ProcessStatePaused:
		return "PAUSED"
	case ProcessStateCompleted:
		return "COMPLETED"
	case ProcessStateAborted:
		return "ABORTED"
	default:
		return "UNKNOWN"
	}
}

// OptOutState represents opt-out state for external control.
type OptOutState uint8

const (
	OptOutStateNone  OptOutState = 0x00
	OptOutStateLocal OptOutState = 0x01
	OptOutStateGrid  OptOutState = 0x02
	OptOutStateAll   OptOutState = 0x03
)

// String returns the optOutState name.
func (v OptOutState) String() string {
	switch v {
	case OptOutStateNone:
		return "NONE"
	case OptOutStateLocal:
		return "LOCAL"
	case OptOutStateGrid:
		return "GRID"
	case OptOutStateAll:
		return "ALL"
	default:
		return "UNKNOWN"
	}
}

// LimitCause represents cause/reason for a limit.
type LimitCause uint8

const (
	LimitCauseGridEmergency     LimitCause = 0x00
	LimitCauseGridOptimization  LimitCause = 0x01
	LimitCauseLocalProtection   LimitCause = 0x02
	LimitCauseLocalOptimization LimitCause = 0x03
	LimitCauseUserPreference    LimitCause = 0x04
)

// String returns the limitCause name.
func (v LimitCause) String() string {
	switch v {
	case LimitCauseGridEmergency:
		return "GRID_EMERGENCY"
	case LimitCauseGridOptimization:
		return "GRID_OPTIMIZATION"
	case LimitCauseLocalProtection:
		return "LOCAL_PROTECTION"
	case LimitCauseLocalOptimization:
		return "LOCAL_OPTIMIZATION"
	case LimitCauseUserPreference:
		return "USER_PREFERENCE"
	default:
		return "UNKNOWN"
	}
}

// SetpointCause represents cause/reason for a setpoint.
type SetpointCause uint8

const (
	SetpointCauseGridRequest       SetpointCause = 0x00
	SetpointCauseSelfConsumption   SetpointCause = 0x01
	SetpointCausePriceOptimization SetpointCause = 0x02
	SetpointCausePhaseBalancing    SetpointCause = 0x03
	SetpointCauseUserPreference    SetpointCause = 0x04
)

// String returns the setpointCause name.
func (v SetpointCause) String() string {
	switch v {
	case SetpointCauseGridRequest:
		return "GRID_REQUEST"
	case SetpointCauseSelfConsumption:
		return "SELF_CONSUMPTION"
	case SetpointCausePriceOptimization:
		return "PRICE_OPTIMIZATION"
	case SetpointCausePhaseBalancing:
		return "PHASE_BALANCING"
	case SetpointCauseUserPreference:
		return "USER_PREFERENCE"
	default:
		return "UNKNOWN"
	}
}

// OverrideReason represents why device is exceeding limits.
type OverrideReason uint8

const (
	OverrideReasonSelfProtection       OverrideReason = 0x00
	OverrideReasonSafety               OverrideReason = 0x01
	OverrideReasonLegalRequirement     OverrideReason = 0x02
	OverrideReasonUncontrolledLoad     OverrideReason = 0x03
	OverrideReasonUncontrolledProducer OverrideReason = 0x04
)

// String returns the overrideReason name.
func (v OverrideReason) String() string {
	switch v {
	case OverrideReasonSelfProtection:
		return "SELF_PROTECTION"
	case OverrideReasonSafety:
		return "SAFETY"
	case OverrideReasonLegalRequirement:
		return "LEGAL_REQUIREMENT"
	case OverrideReasonUncontrolledLoad:
		return "UNCONTROLLED_LOAD"
	case OverrideReasonUncontrolledProducer:
		return "UNCONTROLLED_PRODUCER"
	default:
		return "UNKNOWN"
	}
}

// LimitRejectReason represents why a SetLimit was not applied.
type LimitRejectReason uint8

const (
	LimitRejectReasonBelowMinimum     LimitRejectReason = 0x00
	LimitRejectReasonAboveContractual LimitRejectReason = 0x01
	LimitRejectReasonInvalidValue     LimitRejectReason = 0x02
	LimitRejectReasonDeviceOverride   LimitRejectReason = 0x03
	LimitRejectReasonNotSupported     LimitRejectReason = 0x04
)

// String returns the limitRejectReason name.
func (v LimitRejectReason) String() string {
	switch v {
	case LimitRejectReasonBelowMinimum:
		return "BELOW_MINIMUM"
	case LimitRejectReasonAboveContractual:
		return "ABOVE_CONTRACTUAL"
	case LimitRejectReasonInvalidValue:
		return "INVALID_VALUE"
	case LimitRejectReasonDeviceOverride:
		return "DEVICE_OVERRIDE"
	case LimitRejectReasonNotSupported:
		return "NOT_SUPPORTED"
	default:
		return "UNKNOWN"
	}
}

// EnergyControl wraps a Feature with EnergyControl-specific functionality.
// Energy management: limits, setpoints, process control.
type EnergyControl struct {
	*model.Feature
	onSetLimit              func(ctx context.Context, req SetLimitRequest) (SetLimitResponse, error)
	onClearLimit            func(ctx context.Context, req ClearLimitRequest) error
	onSetCurrentLimits      func(ctx context.Context, req SetCurrentLimitsRequest) error
	onClearCurrentLimits    func(ctx context.Context, req ClearCurrentLimitsRequest) error
	onSetSetpoint           func(ctx context.Context, req SetSetpointRequest) error
	onClearSetpoint         func(ctx context.Context, req ClearSetpointRequest) error
	onSetCurrentSetpoints   func(ctx context.Context, req SetCurrentSetpointsRequest) error
	onClearCurrentSetpoints func(ctx context.Context, req ClearCurrentSetpointsRequest) error
	onPause                 func(ctx context.Context, req PauseRequest) error
	onResume                func(ctx context.Context) error
	onStop                  func(ctx context.Context) error
}

// NewEnergyControl creates a new EnergyControl feature.
func NewEnergyControl() *EnergyControl {
	f := model.NewFeature(model.FeatureEnergyControl, EnergyControlFeatureRevision)

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrDeviceType,
		Name:        "deviceType",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(DeviceTypeOther),
		Description: "Type of controllable device",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrControlState,
		Name:        "controlState",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(ControlStateAutonomous),
		Description: "Control relationship state",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrOptOutState,
		Name:        "optOutState",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadWrite,
		Default:     uint8(OptOutStateNone),
		Description: "Opt-out state for external control",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrAcceptsLimits,
		Name:        "acceptsLimits",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts SetLimit command",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrAcceptsCurrentLimits,
		Name:        "acceptsCurrentLimits",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts SetCurrentLimits command",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrAcceptsSetpoints,
		Name:        "acceptsSetpoints",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts SetSetpoint command",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrAcceptsCurrentSetpoints,
		Name:        "acceptsCurrentSetpoints",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts SetCurrentSetpoints command",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrIsPausable,
		Name:        "isPausable",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts Pause/Resume commands",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrIsShiftable,
		Name:        "isShiftable",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts AdjustStartTime command",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrIsStoppable,
		Name:        "isStoppable",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Accepts Stop command",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveConsumptionLimit,
		Name:        "effectiveConsumptionLimit",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mW",
		Description: "Effective consumption limit (min of all zones)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyConsumptionLimit,
		Name:        "myConsumptionLimit",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadWrite,
		Nullable:    true,
		Unit:        "mW",
		Description: "This zone's consumption limit",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveProductionLimit,
		Name:        "effectiveProductionLimit",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mW",
		Description: "Effective production limit (min of all zones)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyProductionLimit,
		Name:        "myProductionLimit",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadWrite,
		Nullable:    true,
		Unit:        "mW",
		Description: "This zone's production limit",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveCurrentLimitsConsumption,
		Name:        "effectiveCurrentLimitsConsumption",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Effective per-phase current limits (consumption)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyCurrentLimitsConsumption,
		Name:        "myCurrentLimitsConsumption",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "This zone's per-phase current limits (consumption)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveCurrentLimitsProduction,
		Name:        "effectiveCurrentLimitsProduction",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Effective per-phase current limits (production)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyCurrentLimitsProduction,
		Name:        "myCurrentLimitsProduction",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "This zone's per-phase current limits (production)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveConsumptionSetpoint,
		Name:        "effectiveConsumptionSetpoint",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mW",
		Description: "Effective consumption setpoint",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyConsumptionSetpoint,
		Name:        "myConsumptionSetpoint",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadWrite,
		Nullable:    true,
		Unit:        "mW",
		Description: "This zone's consumption setpoint",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveProductionSetpoint,
		Name:        "effectiveProductionSetpoint",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mW",
		Description: "Effective production setpoint",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyProductionSetpoint,
		Name:        "myProductionSetpoint",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadWrite,
		Nullable:    true,
		Unit:        "mW",
		Description: "This zone's production setpoint",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveCurrentSetpointsConsumption,
		Name:        "effectiveCurrentSetpointsConsumption",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Effective per-phase current setpoints (consumption)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyCurrentSetpointsConsumption,
		Name:        "myCurrentSetpointsConsumption",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "This zone's per-phase current setpoints (consumption)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrEffectiveCurrentSetpointsProduction,
		Name:        "effectiveCurrentSetpointsProduction",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Effective per-phase current setpoints (production)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrMyCurrentSetpointsProduction,
		Name:        "myCurrentSetpointsProduction",
		Type:        model.DataTypeMap,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "This zone's per-phase current setpoints (production)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrFailsafeConsumptionLimit,
		Name:        "failsafeConsumptionLimit",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadWrite,
		Nullable:    true,
		Unit:        "mW",
		Description: "Limit to apply in FAILSAFE state",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrFailsafeProductionLimit,
		Name:        "failsafeProductionLimit",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadWrite,
		Nullable:    true,
		Unit:        "mW",
		Description: "Production limit in FAILSAFE state",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrFailsafeDuration,
		Name:        "failsafeDuration",
		Type:        model.DataTypeUint32,
		Access:      model.AccessReadWrite,
		Default:     uint32(7200),
		Unit:        "s",
		Description: "Time in FAILSAFE before returning to AUTONOMOUS (2-24h)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrContractualConsumptionMax,
		Name:        "contractualConsumptionMax",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mW",
		Description: "Building's max allowed consumption (EMS only)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrContractualProductionMax,
		Name:        "contractualProductionMax",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mW",
		Description: "Building's max allowed feed-in (EMS only)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrOverrideReason,
		Name:        "overrideReason",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Why device is in OVERRIDE state",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrOverrideDirection,
		Name:        "overrideDirection",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Which direction triggered override",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrProcessState,
		Name:        "processState",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(ProcessStateNone),
		Description: "Current process lifecycle state",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          EnergyControlAttrOptionalProcess,
		Name:        "optionalProcess",
		Type:        model.DataTypeBool,
		Access:      model.AccessReadOnly,
		Default:     false,
		Description: "Whether the process is optional (can be deferred)",
	}))

	e := &EnergyControl{Feature: f}
	e.addCommands()

	return e
}

// DeviceType returns the type of controllable device.
func (e *EnergyControl) DeviceType() DeviceType {
	val, _ := e.ReadAttribute(EnergyControlAttrDeviceType)
	if v, ok := val.(uint8); ok {
		return DeviceType(v)
	}
	return DeviceTypeOther
}

// ControlState returns the control relationship state.
func (e *EnergyControl) ControlState() ControlState {
	val, _ := e.ReadAttribute(EnergyControlAttrControlState)
	if v, ok := val.(uint8); ok {
		return ControlState(v)
	}
	return ControlStateAutonomous
}

// OptOutState returns the opt-out state for external control.
func (e *EnergyControl) OptOutState() OptOutState {
	val, _ := e.ReadAttribute(EnergyControlAttrOptOutState)
	if v, ok := val.(uint8); ok {
		return OptOutState(v)
	}
	return OptOutStateNone
}

// AcceptsLimits returns the accepts SetLimit command.
func (e *EnergyControl) AcceptsLimits() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrAcceptsLimits)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// AcceptsCurrentLimits returns the accepts SetCurrentLimits command.
func (e *EnergyControl) AcceptsCurrentLimits() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrAcceptsCurrentLimits)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// AcceptsSetpoints returns the accepts SetSetpoint command.
func (e *EnergyControl) AcceptsSetpoints() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrAcceptsSetpoints)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// AcceptsCurrentSetpoints returns the accepts SetCurrentSetpoints command.
func (e *EnergyControl) AcceptsCurrentSetpoints() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrAcceptsCurrentSetpoints)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// IsPausable returns the accepts Pause/Resume commands.
func (e *EnergyControl) IsPausable() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrIsPausable)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// IsShiftable returns the accepts AdjustStartTime command.
func (e *EnergyControl) IsShiftable() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrIsShiftable)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// IsStoppable returns the accepts Stop command.
func (e *EnergyControl) IsStoppable() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrIsStoppable)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// EffectiveConsumptionLimit returns the effective consumption limit (min of all zones).
func (e *EnergyControl) EffectiveConsumptionLimit() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveConsumptionLimit)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// MyConsumptionLimit returns the this zone's consumption limit.
func (e *EnergyControl) MyConsumptionLimit() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyConsumptionLimit)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// EffectiveProductionLimit returns the effective production limit (min of all zones).
func (e *EnergyControl) EffectiveProductionLimit() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveProductionLimit)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// MyProductionLimit returns the this zone's production limit.
func (e *EnergyControl) MyProductionLimit() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyProductionLimit)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// EffectiveCurrentLimitsConsumption returns the effective per-phase current limits (consumption).
func (e *EnergyControl) EffectiveCurrentLimitsConsumption() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveCurrentLimitsConsumption)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// MyCurrentLimitsConsumption returns the this zone's per-phase current limits (consumption).
func (e *EnergyControl) MyCurrentLimitsConsumption() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyCurrentLimitsConsumption)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// EffectiveCurrentLimitsProduction returns the effective per-phase current limits (production).
func (e *EnergyControl) EffectiveCurrentLimitsProduction() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveCurrentLimitsProduction)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// MyCurrentLimitsProduction returns the this zone's per-phase current limits (production).
func (e *EnergyControl) MyCurrentLimitsProduction() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyCurrentLimitsProduction)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// EffectiveConsumptionSetpoint returns the effective consumption setpoint.
func (e *EnergyControl) EffectiveConsumptionSetpoint() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveConsumptionSetpoint)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// MyConsumptionSetpoint returns the this zone's consumption setpoint.
func (e *EnergyControl) MyConsumptionSetpoint() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyConsumptionSetpoint)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// EffectiveProductionSetpoint returns the effective production setpoint.
func (e *EnergyControl) EffectiveProductionSetpoint() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveProductionSetpoint)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// MyProductionSetpoint returns the this zone's production setpoint.
func (e *EnergyControl) MyProductionSetpoint() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyProductionSetpoint)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// EffectiveCurrentSetpointsConsumption returns the effective per-phase current setpoints (consumption).
func (e *EnergyControl) EffectiveCurrentSetpointsConsumption() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveCurrentSetpointsConsumption)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// MyCurrentSetpointsConsumption returns the this zone's per-phase current setpoints (consumption).
func (e *EnergyControl) MyCurrentSetpointsConsumption() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyCurrentSetpointsConsumption)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// EffectiveCurrentSetpointsProduction returns the effective per-phase current setpoints (production).
func (e *EnergyControl) EffectiveCurrentSetpointsProduction() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrEffectiveCurrentSetpointsProduction)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// MyCurrentSetpointsProduction returns the this zone's per-phase current setpoints (production).
func (e *EnergyControl) MyCurrentSetpointsProduction() (map[Phase]int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrMyCurrentSetpointsProduction)
	if err != nil || val == nil {
		return nil, false
	}
	if v, ok := val.(map[Phase]int64); ok {
		return v, true
	}
	return nil, false
}

// FailsafeConsumptionLimit returns the limit to apply in FAILSAFE state.
func (e *EnergyControl) FailsafeConsumptionLimit() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrFailsafeConsumptionLimit)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// FailsafeProductionLimit returns the production limit in FAILSAFE state.
func (e *EnergyControl) FailsafeProductionLimit() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrFailsafeProductionLimit)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// FailsafeDuration returns the time in FAILSAFE before returning to AUTONOMOUS (2-24h).
func (e *EnergyControl) FailsafeDuration() uint32 {
	val, _ := e.ReadAttribute(EnergyControlAttrFailsafeDuration)
	if v, ok := val.(uint32); ok {
		return v
	}
	return uint32(7200)
}

// ContractualConsumptionMax returns the building's max allowed consumption (EMS only).
func (e *EnergyControl) ContractualConsumptionMax() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrContractualConsumptionMax)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// ContractualProductionMax returns the building's max allowed feed-in (EMS only).
func (e *EnergyControl) ContractualProductionMax() (int64, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrContractualProductionMax)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// OverrideReason returns the why device is in OVERRIDE state.
func (e *EnergyControl) OverrideReason() (OverrideReason, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrOverrideReason)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint8); ok {
		return OverrideReason(v), true
	}
	return 0, false
}

// OverrideDirection returns the which direction triggered override.
func (e *EnergyControl) OverrideDirection() (Direction, bool) {
	val, err := e.ReadAttribute(EnergyControlAttrOverrideDirection)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint8); ok {
		return Direction(v), true
	}
	return 0, false
}

// ProcessState returns the current process lifecycle state.
func (e *EnergyControl) ProcessState() ProcessState {
	val, _ := e.ReadAttribute(EnergyControlAttrProcessState)
	if v, ok := val.(uint8); ok {
		return ProcessState(v)
	}
	return ProcessStateNone
}

// OptionalProcess returns the whether the process is optional (can be deferred).
func (e *EnergyControl) OptionalProcess() bool {
	val, _ := e.ReadAttribute(EnergyControlAttrOptionalProcess)
	if v, ok := val.(bool); ok {
		return v
	}
	return false
}

// SetDeviceType sets the type of controllable device.
func (e *EnergyControl) SetDeviceType(deviceType DeviceType) error {
	attr, err := e.GetAttribute(EnergyControlAttrDeviceType)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(deviceType))
}

// SetControlState sets the control relationship state.
func (e *EnergyControl) SetControlState(controlState ControlState) error {
	attr, err := e.GetAttribute(EnergyControlAttrControlState)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(controlState))
}

// SetOptOutState sets the opt-out state for external control.
func (e *EnergyControl) SetOptOutState(optOutState OptOutState) error {
	attr, err := e.GetAttribute(EnergyControlAttrOptOutState)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(optOutState))
}

// SetAcceptsLimits sets the accepts SetLimit command.
func (e *EnergyControl) SetAcceptsLimits(acceptsLimits bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrAcceptsLimits)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(acceptsLimits)
}

// SetAcceptsCurrentLimits sets the accepts SetCurrentLimits command.
func (e *EnergyControl) SetAcceptsCurrentLimits(acceptsCurrentLimits bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrAcceptsCurrentLimits)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(acceptsCurrentLimits)
}

// SetAcceptsSetpoints sets the accepts SetSetpoint command.
func (e *EnergyControl) SetAcceptsSetpoints(acceptsSetpoints bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrAcceptsSetpoints)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(acceptsSetpoints)
}

// SetAcceptsCurrentSetpoints sets the accepts SetCurrentSetpoints command.
func (e *EnergyControl) SetAcceptsCurrentSetpoints(acceptsCurrentSetpoints bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrAcceptsCurrentSetpoints)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(acceptsCurrentSetpoints)
}

// SetIsPausable sets the accepts Pause/Resume commands.
func (e *EnergyControl) SetIsPausable(isPausable bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrIsPausable)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(isPausable)
}

// SetIsShiftable sets the accepts AdjustStartTime command.
func (e *EnergyControl) SetIsShiftable(isShiftable bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrIsShiftable)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(isShiftable)
}

// SetIsStoppable sets the accepts Stop command.
func (e *EnergyControl) SetIsStoppable(isStoppable bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrIsStoppable)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(isStoppable)
}

// SetEffectiveConsumptionLimit sets the effective consumption limit (min of all zones).
func (e *EnergyControl) SetEffectiveConsumptionLimit(effectiveConsumptionLimit int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveConsumptionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveConsumptionLimit)
}

// ClearEffectiveConsumptionLimit clears the effective consumption limit (min of all zones).
func (e *EnergyControl) ClearEffectiveConsumptionLimit() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveConsumptionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveConsumptionLimitPtr sets or clears the effective consumption limit (min of all zones) from a pointer.
func (e *EnergyControl) SetEffectiveConsumptionLimitPtr(v *int64) error {
	if v == nil {
		return e.ClearEffectiveConsumptionLimit()
	}
	return e.SetEffectiveConsumptionLimit(*v)
}

// SetMyConsumptionLimit sets the this zone's consumption limit.
func (e *EnergyControl) SetMyConsumptionLimit(myConsumptionLimit int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyConsumptionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myConsumptionLimit)
}

// ClearMyConsumptionLimit clears the this zone's consumption limit.
func (e *EnergyControl) ClearMyConsumptionLimit() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyConsumptionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyConsumptionLimitPtr sets or clears the this zone's consumption limit from a pointer.
func (e *EnergyControl) SetMyConsumptionLimitPtr(v *int64) error {
	if v == nil {
		return e.ClearMyConsumptionLimit()
	}
	return e.SetMyConsumptionLimit(*v)
}

// SetEffectiveProductionLimit sets the effective production limit (min of all zones).
func (e *EnergyControl) SetEffectiveProductionLimit(effectiveProductionLimit int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveProductionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveProductionLimit)
}

// ClearEffectiveProductionLimit clears the effective production limit (min of all zones).
func (e *EnergyControl) ClearEffectiveProductionLimit() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveProductionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveProductionLimitPtr sets or clears the effective production limit (min of all zones) from a pointer.
func (e *EnergyControl) SetEffectiveProductionLimitPtr(v *int64) error {
	if v == nil {
		return e.ClearEffectiveProductionLimit()
	}
	return e.SetEffectiveProductionLimit(*v)
}

// SetMyProductionLimit sets the this zone's production limit.
func (e *EnergyControl) SetMyProductionLimit(myProductionLimit int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyProductionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myProductionLimit)
}

// ClearMyProductionLimit clears the this zone's production limit.
func (e *EnergyControl) ClearMyProductionLimit() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyProductionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyProductionLimitPtr sets or clears the this zone's production limit from a pointer.
func (e *EnergyControl) SetMyProductionLimitPtr(v *int64) error {
	if v == nil {
		return e.ClearMyProductionLimit()
	}
	return e.SetMyProductionLimit(*v)
}

// SetEffectiveCurrentLimitsConsumption sets the effective per-phase current limits (consumption).
func (e *EnergyControl) SetEffectiveCurrentLimitsConsumption(effectiveCurrentLimitsConsumption map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentLimitsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveCurrentLimitsConsumption)
}

// ClearEffectiveCurrentLimitsConsumption clears the effective per-phase current limits (consumption).
func (e *EnergyControl) ClearEffectiveCurrentLimitsConsumption() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentLimitsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveCurrentLimitsConsumptionPtr sets or clears the effective per-phase current limits (consumption) from a pointer.
func (e *EnergyControl) SetEffectiveCurrentLimitsConsumptionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearEffectiveCurrentLimitsConsumption()
	}
	return e.SetEffectiveCurrentLimitsConsumption(*v)
}

// SetMyCurrentLimitsConsumption sets the this zone's per-phase current limits (consumption).
func (e *EnergyControl) SetMyCurrentLimitsConsumption(myCurrentLimitsConsumption map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentLimitsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myCurrentLimitsConsumption)
}

// ClearMyCurrentLimitsConsumption clears the this zone's per-phase current limits (consumption).
func (e *EnergyControl) ClearMyCurrentLimitsConsumption() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentLimitsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyCurrentLimitsConsumptionPtr sets or clears the this zone's per-phase current limits (consumption) from a pointer.
func (e *EnergyControl) SetMyCurrentLimitsConsumptionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearMyCurrentLimitsConsumption()
	}
	return e.SetMyCurrentLimitsConsumption(*v)
}

// SetEffectiveCurrentLimitsProduction sets the effective per-phase current limits (production).
func (e *EnergyControl) SetEffectiveCurrentLimitsProduction(effectiveCurrentLimitsProduction map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentLimitsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveCurrentLimitsProduction)
}

// ClearEffectiveCurrentLimitsProduction clears the effective per-phase current limits (production).
func (e *EnergyControl) ClearEffectiveCurrentLimitsProduction() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentLimitsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveCurrentLimitsProductionPtr sets or clears the effective per-phase current limits (production) from a pointer.
func (e *EnergyControl) SetEffectiveCurrentLimitsProductionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearEffectiveCurrentLimitsProduction()
	}
	return e.SetEffectiveCurrentLimitsProduction(*v)
}

// SetMyCurrentLimitsProduction sets the this zone's per-phase current limits (production).
func (e *EnergyControl) SetMyCurrentLimitsProduction(myCurrentLimitsProduction map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentLimitsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myCurrentLimitsProduction)
}

// ClearMyCurrentLimitsProduction clears the this zone's per-phase current limits (production).
func (e *EnergyControl) ClearMyCurrentLimitsProduction() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentLimitsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyCurrentLimitsProductionPtr sets or clears the this zone's per-phase current limits (production) from a pointer.
func (e *EnergyControl) SetMyCurrentLimitsProductionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearMyCurrentLimitsProduction()
	}
	return e.SetMyCurrentLimitsProduction(*v)
}

// SetEffectiveConsumptionSetpoint sets the effective consumption setpoint.
func (e *EnergyControl) SetEffectiveConsumptionSetpoint(effectiveConsumptionSetpoint int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveConsumptionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveConsumptionSetpoint)
}

// ClearEffectiveConsumptionSetpoint clears the effective consumption setpoint.
func (e *EnergyControl) ClearEffectiveConsumptionSetpoint() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveConsumptionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveConsumptionSetpointPtr sets or clears the effective consumption setpoint from a pointer.
func (e *EnergyControl) SetEffectiveConsumptionSetpointPtr(v *int64) error {
	if v == nil {
		return e.ClearEffectiveConsumptionSetpoint()
	}
	return e.SetEffectiveConsumptionSetpoint(*v)
}

// SetMyConsumptionSetpoint sets the this zone's consumption setpoint.
func (e *EnergyControl) SetMyConsumptionSetpoint(myConsumptionSetpoint int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyConsumptionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myConsumptionSetpoint)
}

// ClearMyConsumptionSetpoint clears the this zone's consumption setpoint.
func (e *EnergyControl) ClearMyConsumptionSetpoint() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyConsumptionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyConsumptionSetpointPtr sets or clears the this zone's consumption setpoint from a pointer.
func (e *EnergyControl) SetMyConsumptionSetpointPtr(v *int64) error {
	if v == nil {
		return e.ClearMyConsumptionSetpoint()
	}
	return e.SetMyConsumptionSetpoint(*v)
}

// SetEffectiveProductionSetpoint sets the effective production setpoint.
func (e *EnergyControl) SetEffectiveProductionSetpoint(effectiveProductionSetpoint int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveProductionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveProductionSetpoint)
}

// ClearEffectiveProductionSetpoint clears the effective production setpoint.
func (e *EnergyControl) ClearEffectiveProductionSetpoint() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveProductionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveProductionSetpointPtr sets or clears the effective production setpoint from a pointer.
func (e *EnergyControl) SetEffectiveProductionSetpointPtr(v *int64) error {
	if v == nil {
		return e.ClearEffectiveProductionSetpoint()
	}
	return e.SetEffectiveProductionSetpoint(*v)
}

// SetMyProductionSetpoint sets the this zone's production setpoint.
func (e *EnergyControl) SetMyProductionSetpoint(myProductionSetpoint int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyProductionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myProductionSetpoint)
}

// ClearMyProductionSetpoint clears the this zone's production setpoint.
func (e *EnergyControl) ClearMyProductionSetpoint() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyProductionSetpoint)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyProductionSetpointPtr sets or clears the this zone's production setpoint from a pointer.
func (e *EnergyControl) SetMyProductionSetpointPtr(v *int64) error {
	if v == nil {
		return e.ClearMyProductionSetpoint()
	}
	return e.SetMyProductionSetpoint(*v)
}

// SetEffectiveCurrentSetpointsConsumption sets the effective per-phase current setpoints (consumption).
func (e *EnergyControl) SetEffectiveCurrentSetpointsConsumption(effectiveCurrentSetpointsConsumption map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentSetpointsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveCurrentSetpointsConsumption)
}

// ClearEffectiveCurrentSetpointsConsumption clears the effective per-phase current setpoints (consumption).
func (e *EnergyControl) ClearEffectiveCurrentSetpointsConsumption() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentSetpointsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveCurrentSetpointsConsumptionPtr sets or clears the effective per-phase current setpoints (consumption) from a pointer.
func (e *EnergyControl) SetEffectiveCurrentSetpointsConsumptionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearEffectiveCurrentSetpointsConsumption()
	}
	return e.SetEffectiveCurrentSetpointsConsumption(*v)
}

// SetMyCurrentSetpointsConsumption sets the this zone's per-phase current setpoints (consumption).
func (e *EnergyControl) SetMyCurrentSetpointsConsumption(myCurrentSetpointsConsumption map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentSetpointsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myCurrentSetpointsConsumption)
}

// ClearMyCurrentSetpointsConsumption clears the this zone's per-phase current setpoints (consumption).
func (e *EnergyControl) ClearMyCurrentSetpointsConsumption() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentSetpointsConsumption)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyCurrentSetpointsConsumptionPtr sets or clears the this zone's per-phase current setpoints (consumption) from a pointer.
func (e *EnergyControl) SetMyCurrentSetpointsConsumptionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearMyCurrentSetpointsConsumption()
	}
	return e.SetMyCurrentSetpointsConsumption(*v)
}

// SetEffectiveCurrentSetpointsProduction sets the effective per-phase current setpoints (production).
func (e *EnergyControl) SetEffectiveCurrentSetpointsProduction(effectiveCurrentSetpointsProduction map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentSetpointsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(effectiveCurrentSetpointsProduction)
}

// ClearEffectiveCurrentSetpointsProduction clears the effective per-phase current setpoints (production).
func (e *EnergyControl) ClearEffectiveCurrentSetpointsProduction() error {
	attr, err := e.GetAttribute(EnergyControlAttrEffectiveCurrentSetpointsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEffectiveCurrentSetpointsProductionPtr sets or clears the effective per-phase current setpoints (production) from a pointer.
func (e *EnergyControl) SetEffectiveCurrentSetpointsProductionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearEffectiveCurrentSetpointsProduction()
	}
	return e.SetEffectiveCurrentSetpointsProduction(*v)
}

// SetMyCurrentSetpointsProduction sets the this zone's per-phase current setpoints (production).
func (e *EnergyControl) SetMyCurrentSetpointsProduction(myCurrentSetpointsProduction map[Phase]int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentSetpointsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(myCurrentSetpointsProduction)
}

// ClearMyCurrentSetpointsProduction clears the this zone's per-phase current setpoints (production).
func (e *EnergyControl) ClearMyCurrentSetpointsProduction() error {
	attr, err := e.GetAttribute(EnergyControlAttrMyCurrentSetpointsProduction)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetMyCurrentSetpointsProductionPtr sets or clears the this zone's per-phase current setpoints (production) from a pointer.
func (e *EnergyControl) SetMyCurrentSetpointsProductionPtr(v *map[Phase]int64) error {
	if v == nil {
		return e.ClearMyCurrentSetpointsProduction()
	}
	return e.SetMyCurrentSetpointsProduction(*v)
}

// SetFailsafeConsumptionLimit sets the limit to apply in FAILSAFE state.
func (e *EnergyControl) SetFailsafeConsumptionLimit(failsafeConsumptionLimit int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrFailsafeConsumptionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(failsafeConsumptionLimit)
}

// ClearFailsafeConsumptionLimit clears the limit to apply in FAILSAFE state.
func (e *EnergyControl) ClearFailsafeConsumptionLimit() error {
	attr, err := e.GetAttribute(EnergyControlAttrFailsafeConsumptionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetFailsafeConsumptionLimitPtr sets or clears the limit to apply in FAILSAFE state from a pointer.
func (e *EnergyControl) SetFailsafeConsumptionLimitPtr(v *int64) error {
	if v == nil {
		return e.ClearFailsafeConsumptionLimit()
	}
	return e.SetFailsafeConsumptionLimit(*v)
}

// SetFailsafeProductionLimit sets the production limit in FAILSAFE state.
func (e *EnergyControl) SetFailsafeProductionLimit(failsafeProductionLimit int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrFailsafeProductionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(failsafeProductionLimit)
}

// ClearFailsafeProductionLimit clears the production limit in FAILSAFE state.
func (e *EnergyControl) ClearFailsafeProductionLimit() error {
	attr, err := e.GetAttribute(EnergyControlAttrFailsafeProductionLimit)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetFailsafeProductionLimitPtr sets or clears the production limit in FAILSAFE state from a pointer.
func (e *EnergyControl) SetFailsafeProductionLimitPtr(v *int64) error {
	if v == nil {
		return e.ClearFailsafeProductionLimit()
	}
	return e.SetFailsafeProductionLimit(*v)
}

// SetFailsafeDuration sets the time in FAILSAFE before returning to AUTONOMOUS (2-24h).
func (e *EnergyControl) SetFailsafeDuration(failsafeDuration uint32) error {
	attr, err := e.GetAttribute(EnergyControlAttrFailsafeDuration)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(failsafeDuration)
}

// SetContractualConsumptionMax sets the building's max allowed consumption (EMS only).
func (e *EnergyControl) SetContractualConsumptionMax(contractualConsumptionMax int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrContractualConsumptionMax)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(contractualConsumptionMax)
}

// ClearContractualConsumptionMax clears the building's max allowed consumption (EMS only).
func (e *EnergyControl) ClearContractualConsumptionMax() error {
	attr, err := e.GetAttribute(EnergyControlAttrContractualConsumptionMax)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetContractualConsumptionMaxPtr sets or clears the building's max allowed consumption (EMS only) from a pointer.
func (e *EnergyControl) SetContractualConsumptionMaxPtr(v *int64) error {
	if v == nil {
		return e.ClearContractualConsumptionMax()
	}
	return e.SetContractualConsumptionMax(*v)
}

// SetContractualProductionMax sets the building's max allowed feed-in (EMS only).
func (e *EnergyControl) SetContractualProductionMax(contractualProductionMax int64) error {
	attr, err := e.GetAttribute(EnergyControlAttrContractualProductionMax)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(contractualProductionMax)
}

// ClearContractualProductionMax clears the building's max allowed feed-in (EMS only).
func (e *EnergyControl) ClearContractualProductionMax() error {
	attr, err := e.GetAttribute(EnergyControlAttrContractualProductionMax)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetContractualProductionMaxPtr sets or clears the building's max allowed feed-in (EMS only) from a pointer.
func (e *EnergyControl) SetContractualProductionMaxPtr(v *int64) error {
	if v == nil {
		return e.ClearContractualProductionMax()
	}
	return e.SetContractualProductionMax(*v)
}

// SetOverrideReason sets the why device is in OVERRIDE state.
func (e *EnergyControl) SetOverrideReason(overrideReason OverrideReason) error {
	attr, err := e.GetAttribute(EnergyControlAttrOverrideReason)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(overrideReason))
}

// ClearOverrideReason clears the why device is in OVERRIDE state.
func (e *EnergyControl) ClearOverrideReason() error {
	attr, err := e.GetAttribute(EnergyControlAttrOverrideReason)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetOverrideReasonPtr sets or clears the why device is in OVERRIDE state from a pointer.
func (e *EnergyControl) SetOverrideReasonPtr(v *OverrideReason) error {
	if v == nil {
		return e.ClearOverrideReason()
	}
	return e.SetOverrideReason(*v)
}

// SetOverrideDirection sets the which direction triggered override.
func (e *EnergyControl) SetOverrideDirection(overrideDirection Direction) error {
	attr, err := e.GetAttribute(EnergyControlAttrOverrideDirection)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(overrideDirection))
}

// ClearOverrideDirection clears the which direction triggered override.
func (e *EnergyControl) ClearOverrideDirection() error {
	attr, err := e.GetAttribute(EnergyControlAttrOverrideDirection)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetOverrideDirectionPtr sets or clears the which direction triggered override from a pointer.
func (e *EnergyControl) SetOverrideDirectionPtr(v *Direction) error {
	if v == nil {
		return e.ClearOverrideDirection()
	}
	return e.SetOverrideDirection(*v)
}

// SetProcessState sets the current process lifecycle state.
func (e *EnergyControl) SetProcessState(processState ProcessState) error {
	attr, err := e.GetAttribute(EnergyControlAttrProcessState)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(processState))
}

// SetOptionalProcess sets the whether the process is optional (can be deferred).
func (e *EnergyControl) SetOptionalProcess(optionalProcess bool) error {
	attr, err := e.GetAttribute(EnergyControlAttrOptionalProcess)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(optionalProcess)
}

// EnergyControl command IDs.
const (
	EnergyControlCmdSetLimit              uint8 = 1
	EnergyControlCmdClearLimit            uint8 = 2
	EnergyControlCmdSetCurrentLimits      uint8 = 3
	EnergyControlCmdClearCurrentLimits    uint8 = 4
	EnergyControlCmdSetSetpoint           uint8 = 5
	EnergyControlCmdClearSetpoint         uint8 = 6
	EnergyControlCmdSetCurrentSetpoints   uint8 = 7
	EnergyControlCmdClearCurrentSetpoints uint8 = 8
	EnergyControlCmdPause                 uint8 = 9
	EnergyControlCmdResume                uint8 = 10
	EnergyControlCmdStop                  uint8 = 11
)

// SetLimitRequest represents the setLimit command parameters.
type SetLimitRequest struct {
	ConsumptionLimit *int64
	ProductionLimit  *int64
	Duration         *uint32
	Cause            LimitCause
}

// SetLimitResponse represents the setLimit command response.
type SetLimitResponse struct {
	Applied                   bool
	ControlState              ControlState
	EffectiveConsumptionLimit *int64
	EffectiveProductionLimit  *int64
	RejectReason              *LimitRejectReason
}

// ClearLimitRequest represents the clearLimit command parameters.
type ClearLimitRequest struct {
	Direction *Direction
}

// SetCurrentLimitsRequest represents the setCurrentLimits command parameters.
type SetCurrentLimitsRequest struct {
	Phases    map[string]any
	Direction Direction
	Duration  *uint32
	Cause     LimitCause
}

// ClearCurrentLimitsRequest represents the clearCurrentLimits command parameters.
type ClearCurrentLimitsRequest struct {
	Direction *Direction
}

// SetSetpointRequest represents the setSetpoint command parameters.
type SetSetpointRequest struct {
	ConsumptionSetpoint *int64
	ProductionSetpoint  *int64
	Duration            *uint32
	Cause               SetpointCause
}

// ClearSetpointRequest represents the clearSetpoint command parameters.
type ClearSetpointRequest struct {
	Direction *Direction
}

// SetCurrentSetpointsRequest represents the setCurrentSetpoints command parameters.
type SetCurrentSetpointsRequest struct {
	Phases    map[string]any
	Direction Direction
	Duration  *uint32
	Cause     SetpointCause
}

// ClearCurrentSetpointsRequest represents the clearCurrentSetpoints command parameters.
type ClearCurrentSetpointsRequest struct {
	Direction *Direction
}

// PauseRequest represents the pause command parameters.
type PauseRequest struct {
	Duration *uint32
}

// addCommands adds the EnergyControl commands.
func (e *EnergyControl) addCommands() {
	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdSetLimit,
		Name:        "setLimit",
		Description: "Set power limits for this zone",
		Parameters: []model.ParameterMetadata{
			{Name: "consumptionLimit", Type: model.DataTypeInt64, Required: false},
			{Name: "productionLimit", Type: model.DataTypeInt64, Required: false},
			{Name: "duration", Type: model.DataTypeUint32, Required: false},
			{Name: "cause", Type: model.DataTypeUint8, Required: true},
		},
	}, e.handleSetLimit))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdClearLimit,
		Name:        "clearLimit",
		Description: "Remove this zone's power limits",
		Parameters: []model.ParameterMetadata{
			{Name: "direction", Type: model.DataTypeUint8, Required: false},
		},
	}, e.handleClearLimit))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdSetCurrentLimits,
		Name:        "setCurrentLimits",
		Description: "Set per-phase current limits",
		Parameters: []model.ParameterMetadata{
			{Name: "phases", Type: model.DataTypeMap, Required: true},
			{Name: "direction", Type: model.DataTypeUint8, Required: true},
			{Name: "duration", Type: model.DataTypeUint32, Required: false},
			{Name: "cause", Type: model.DataTypeUint8, Required: true},
		},
	}, e.handleSetCurrentLimits))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdClearCurrentLimits,
		Name:        "clearCurrentLimits",
		Description: "Remove this zone's per-phase current limits",
		Parameters: []model.ParameterMetadata{
			{Name: "direction", Type: model.DataTypeUint8, Required: false},
		},
	}, e.handleClearCurrentLimits))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdSetSetpoint,
		Name:        "setSetpoint",
		Description: "Set power setpoint for this zone",
		Parameters: []model.ParameterMetadata{
			{Name: "consumptionSetpoint", Type: model.DataTypeInt64, Required: false},
			{Name: "productionSetpoint", Type: model.DataTypeInt64, Required: false},
			{Name: "duration", Type: model.DataTypeUint32, Required: false},
			{Name: "cause", Type: model.DataTypeUint8, Required: true},
		},
	}, e.handleSetSetpoint))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdClearSetpoint,
		Name:        "clearSetpoint",
		Description: "Remove this zone's power setpoints",
		Parameters: []model.ParameterMetadata{
			{Name: "direction", Type: model.DataTypeUint8, Required: false},
		},
	}, e.handleClearSetpoint))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdSetCurrentSetpoints,
		Name:        "setCurrentSetpoints",
		Description: "Set per-phase current setpoints",
		Parameters: []model.ParameterMetadata{
			{Name: "phases", Type: model.DataTypeMap, Required: true},
			{Name: "direction", Type: model.DataTypeUint8, Required: true},
			{Name: "duration", Type: model.DataTypeUint32, Required: false},
			{Name: "cause", Type: model.DataTypeUint8, Required: true},
		},
	}, e.handleSetCurrentSetpoints))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdClearCurrentSetpoints,
		Name:        "clearCurrentSetpoints",
		Description: "Remove this zone's per-phase current setpoints",
		Parameters: []model.ParameterMetadata{
			{Name: "direction", Type: model.DataTypeUint8, Required: false},
		},
	}, e.handleClearCurrentSetpoints))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdPause,
		Name:        "pause",
		Description: "Temporarily pause device operation",
		Parameters: []model.ParameterMetadata{
			{Name: "duration", Type: model.DataTypeUint32, Required: false},
		},
	}, e.handlePause))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdResume,
		Name:        "resume",
		Description: "Resume paused operation",
	}, e.handleResume))

	e.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          EnergyControlCmdStop,
		Name:        "stop",
		Description: "Abort task completely",
	}, e.handleStop))

}

func (e *EnergyControl) handleSetLimit(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onSetLimit == nil {
		return map[string]any{"applied": false}, nil
	}

	req := SetLimitRequest{}
	if raw, exists := params["consumptionLimit"]; exists {
		if v, ok := wire.ToInt64(raw); ok {
			req.ConsumptionLimit = &v
		}
	}
	if raw, exists := params["productionLimit"]; exists {
		if v, ok := wire.ToInt64(raw); ok {
			req.ProductionLimit = &v
		}
	}
	if raw, exists := params["duration"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.Duration = &v
		}
	}
	if raw, exists := params["cause"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Cause = LimitCause(v)
		}
	}

	resp, err := e.onSetLimit(ctx, req)
	if err != nil {
		return nil, err
	}

	result := make(map[string]any)
	result["applied"] = resp.Applied
	result["controlState"] = uint8(resp.ControlState)
	if resp.EffectiveConsumptionLimit != nil {
		result["effectiveConsumptionLimit"] = *resp.EffectiveConsumptionLimit
	}
	if resp.EffectiveProductionLimit != nil {
		result["effectiveProductionLimit"] = *resp.EffectiveProductionLimit
	}
	if resp.RejectReason != nil {
		result["rejectReason"] = uint8(*resp.RejectReason)
	}
	return result, nil
}

func (e *EnergyControl) handleClearLimit(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onClearLimit == nil {
		return map[string]any{"success": false}, nil
	}

	req := ClearLimitRequest{}
	if raw, exists := params["direction"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			tmp := Direction(v)
			req.Direction = &tmp
		}
	}

	err := e.onClearLimit(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleSetCurrentLimits(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onSetCurrentLimits == nil {
		return map[string]any{"success": false}, nil
	}

	req := SetCurrentLimitsRequest{}
	if raw, exists := params["phases"]; exists {
		if v, ok := raw.(map[string]any); ok {
			req.Phases = v
		}
	}
	if raw, exists := params["direction"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Direction = Direction(v)
		}
	}
	if raw, exists := params["duration"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.Duration = &v
		}
	}
	if raw, exists := params["cause"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Cause = LimitCause(v)
		}
	}

	err := e.onSetCurrentLimits(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleClearCurrentLimits(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onClearCurrentLimits == nil {
		return map[string]any{"success": false}, nil
	}

	req := ClearCurrentLimitsRequest{}
	if raw, exists := params["direction"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			tmp := Direction(v)
			req.Direction = &tmp
		}
	}

	err := e.onClearCurrentLimits(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleSetSetpoint(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onSetSetpoint == nil {
		return map[string]any{"success": false}, nil
	}

	req := SetSetpointRequest{}
	if raw, exists := params["consumptionSetpoint"]; exists {
		if v, ok := wire.ToInt64(raw); ok {
			req.ConsumptionSetpoint = &v
		}
	}
	if raw, exists := params["productionSetpoint"]; exists {
		if v, ok := wire.ToInt64(raw); ok {
			req.ProductionSetpoint = &v
		}
	}
	if raw, exists := params["duration"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.Duration = &v
		}
	}
	if raw, exists := params["cause"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Cause = SetpointCause(v)
		}
	}

	err := e.onSetSetpoint(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleClearSetpoint(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onClearSetpoint == nil {
		return map[string]any{"success": false}, nil
	}

	req := ClearSetpointRequest{}
	if raw, exists := params["direction"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			tmp := Direction(v)
			req.Direction = &tmp
		}
	}

	err := e.onClearSetpoint(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleSetCurrentSetpoints(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onSetCurrentSetpoints == nil {
		return map[string]any{"success": false}, nil
	}

	req := SetCurrentSetpointsRequest{}
	if raw, exists := params["phases"]; exists {
		if v, ok := raw.(map[string]any); ok {
			req.Phases = v
		}
	}
	if raw, exists := params["direction"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Direction = Direction(v)
		}
	}
	if raw, exists := params["duration"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.Duration = &v
		}
	}
	if raw, exists := params["cause"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			req.Cause = SetpointCause(v)
		}
	}

	err := e.onSetCurrentSetpoints(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleClearCurrentSetpoints(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onClearCurrentSetpoints == nil {
		return map[string]any{"success": false}, nil
	}

	req := ClearCurrentSetpointsRequest{}
	if raw, exists := params["direction"]; exists {
		if v, ok := wire.ToUint8Public(raw); ok {
			tmp := Direction(v)
			req.Direction = &tmp
		}
	}

	err := e.onClearCurrentSetpoints(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handlePause(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onPause == nil {
		return map[string]any{"success": false}, nil
	}

	req := PauseRequest{}
	if raw, exists := params["duration"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.Duration = &v
		}
	}

	err := e.onPause(ctx, req)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleResume(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onResume == nil {
		return map[string]any{"success": false}, nil
	}

	err := e.onResume(ctx)
	return map[string]any{"success": err == nil}, err
}

func (e *EnergyControl) handleStop(ctx context.Context, params map[string]any) (map[string]any, error) {
	if e.onStop == nil {
		return map[string]any{"success": false}, nil
	}

	err := e.onStop(ctx)
	return map[string]any{"success": err == nil}, err
}

// OnSetLimit sets the handler for setLimit command.
func (e *EnergyControl) OnSetLimit(handler func(ctx context.Context, req SetLimitRequest) (SetLimitResponse, error)) {
	e.onSetLimit = handler
}

// OnClearLimit sets the handler for clearLimit command.
func (e *EnergyControl) OnClearLimit(handler func(ctx context.Context, req ClearLimitRequest) error) {
	e.onClearLimit = handler
}

// OnSetCurrentLimits sets the handler for setCurrentLimits command.
func (e *EnergyControl) OnSetCurrentLimits(handler func(ctx context.Context, req SetCurrentLimitsRequest) error) {
	e.onSetCurrentLimits = handler
}

// OnClearCurrentLimits sets the handler for clearCurrentLimits command.
func (e *EnergyControl) OnClearCurrentLimits(handler func(ctx context.Context, req ClearCurrentLimitsRequest) error) {
	e.onClearCurrentLimits = handler
}

// OnSetSetpoint sets the handler for setSetpoint command.
func (e *EnergyControl) OnSetSetpoint(handler func(ctx context.Context, req SetSetpointRequest) error) {
	e.onSetSetpoint = handler
}

// OnClearSetpoint sets the handler for clearSetpoint command.
func (e *EnergyControl) OnClearSetpoint(handler func(ctx context.Context, req ClearSetpointRequest) error) {
	e.onClearSetpoint = handler
}

// OnSetCurrentSetpoints sets the handler for setCurrentSetpoints command.
func (e *EnergyControl) OnSetCurrentSetpoints(handler func(ctx context.Context, req SetCurrentSetpointsRequest) error) {
	e.onSetCurrentSetpoints = handler
}

// OnClearCurrentSetpoints sets the handler for clearCurrentSetpoints command.
func (e *EnergyControl) OnClearCurrentSetpoints(handler func(ctx context.Context, req ClearCurrentSetpointsRequest) error) {
	e.onClearCurrentSetpoints = handler
}

// OnPause sets the handler for pause command.
func (e *EnergyControl) OnPause(handler func(ctx context.Context, req PauseRequest) error) {
	e.onPause = handler
}

// OnResume sets the handler for resume command.
func (e *EnergyControl) OnResume(handler func(ctx context.Context) error) {
	e.onResume = handler
}

// OnStop sets the handler for stop command.
func (e *EnergyControl) OnStop(handler func(ctx context.Context) error) {
	e.onStop = handler
}
