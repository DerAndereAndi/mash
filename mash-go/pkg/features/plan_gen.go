// Code generated by mash-featgen. DO NOT EDIT.

package features

import (
	"context"

	"github.com/mash-protocol/mash-go/pkg/model"
	"github.com/mash-protocol/mash-go/pkg/wire"
)

// Plan attribute IDs.
const (
	PlanAttrPlanID             uint16 = 1
	PlanAttrPlanVersion        uint16 = 2
	PlanAttrCommitment         uint16 = 3
	PlanAttrStartTime          uint16 = 10
	PlanAttrEndTime            uint16 = 11
	PlanAttrTotalEnergyPlanned uint16 = 20
	PlanAttrSlots              uint16 = 40
)

// PlanFeatureRevision is the current revision of the Plan feature.
const PlanFeatureRevision uint16 = 1

// Commitment represents how firm the plan is.
type Commitment uint8

const (
	// CommitmentPreliminary initial draft, likely to change.
	CommitmentPreliminary Commitment = 0x00
	// CommitmentTentative proposed, awaiting acceptance.
	CommitmentTentative Commitment = 0x01
	// CommitmentCommitted accepted and scheduled.
	CommitmentCommitted Commitment = 0x02
	// CommitmentExecuting currently being executed.
	CommitmentExecuting Commitment = 0x03
)

// String returns the commitment name.
func (v Commitment) String() string {
	switch v {
	case CommitmentPreliminary:
		return "PRELIMINARY"
	case CommitmentTentative:
		return "TENTATIVE"
	case CommitmentCommitted:
		return "COMMITTED"
	case CommitmentExecuting:
		return "EXECUTING"
	default:
		return "UNKNOWN"
	}
}

// PlanSlot represents an item in the slots array.
type PlanSlot struct {
	Duration     uint32
	PlannedPower int64
	MinPower     int64
	MaxPower     int64
}

// Plan wraps a Feature with Plan-specific functionality.
// Device reports intended power behavior. Commitment levels support negotiation.
type Plan struct {
	*model.Feature
	onRequestPlan func(ctx context.Context, req RequestPlanRequest) (RequestPlanResponse, error)
	onAcceptPlan  func(ctx context.Context, req AcceptPlanRequest) (AcceptPlanResponse, error)
}

// NewPlan creates a new Plan feature.
func NewPlan() *Plan {
	f := model.NewFeature(model.FeaturePlan, PlanFeatureRevision)

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrPlanID,
		Name:        "planId",
		Type:        model.DataTypeUint32,
		Access:      model.AccessReadOnly,
		Default:     uint32(0),
		Description: "Unique plan identifier",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrPlanVersion,
		Name:        "planVersion",
		Type:        model.DataTypeUint32,
		Access:      model.AccessReadOnly,
		Default:     uint32(0),
		Description: "Increments on each plan update",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrCommitment,
		Name:        "commitment",
		Type:        model.DataTypeUint8,
		Access:      model.AccessReadOnly,
		Default:     uint8(CommitmentPreliminary),
		Description: "How firm this plan is",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrStartTime,
		Name:        "startTime",
		Type:        model.DataTypeUint64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "When the plan starts (Unix timestamp)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrEndTime,
		Name:        "endTime",
		Type:        model.DataTypeUint64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "When the plan ends (Unix timestamp)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrTotalEnergyPlanned,
		Name:        "totalEnergyPlanned",
		Type:        model.DataTypeInt64,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Unit:        "mWh",
		Description: "Total planned energy (positive=consumption, negative=production)",
	}))

	f.AddAttribute(model.NewAttribute(&model.AttributeMetadata{
		ID:          PlanAttrSlots,
		Name:        "slots",
		Type:        model.DataTypeArray,
		Access:      model.AccessReadOnly,
		Nullable:    true,
		Description: "Planned power behavior slots",
	}))

	p := &Plan{Feature: f}
	p.addCommands()

	return p
}

// PlanID returns the unique plan identifier.
func (p *Plan) PlanID() uint32 {
	val, _ := p.ReadAttribute(PlanAttrPlanID)
	if v, ok := val.(uint32); ok {
		return v
	}
	return uint32(0)
}

// PlanVersion returns the increments on each plan update.
func (p *Plan) PlanVersion() uint32 {
	val, _ := p.ReadAttribute(PlanAttrPlanVersion)
	if v, ok := val.(uint32); ok {
		return v
	}
	return uint32(0)
}

// Commitment returns the how firm this plan is.
func (p *Plan) Commitment() Commitment {
	val, _ := p.ReadAttribute(PlanAttrCommitment)
	if v, ok := val.(uint8); ok {
		return Commitment(v)
	}
	return CommitmentPreliminary
}

// StartTime returns the when the plan starts (Unix timestamp).
func (p *Plan) StartTime() (uint64, bool) {
	val, err := p.ReadAttribute(PlanAttrStartTime)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint64); ok {
		return v, true
	}
	return 0, false
}

// EndTime returns the when the plan ends (Unix timestamp).
func (p *Plan) EndTime() (uint64, bool) {
	val, err := p.ReadAttribute(PlanAttrEndTime)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(uint64); ok {
		return v, true
	}
	return 0, false
}

// TotalEnergyPlanned returns the total planned energy (positive=consumption, negative=production).
func (p *Plan) TotalEnergyPlanned() (int64, bool) {
	val, err := p.ReadAttribute(PlanAttrTotalEnergyPlanned)
	if err != nil || val == nil {
		return 0, false
	}
	if v, ok := val.(int64); ok {
		return v, true
	}
	return 0, false
}

// Slots returns the planned power behavior slots.
func (p *Plan) Slots() ([]PlanSlot, bool) {
	val, err := p.ReadAttribute(PlanAttrSlots)
	if err != nil || val == nil {
		return nil, false
	}
	raw, ok := val.([]any)
	if !ok {
		return nil, false
	}
	result := make([]PlanSlot, 0, len(raw))
	for _, item := range raw {
		m, ok := item.(map[string]any)
		if !ok {
			continue
		}
		entry := PlanSlot{}
		if v, ok := m["duration"]; ok {
			if n, ok := v.(uint32); ok {
				entry.Duration = n
			}
		}
		if v, ok := m["plannedPower"]; ok {
			if n, ok := v.(int64); ok {
				entry.PlannedPower = n
			}
		}
		if v, ok := m["minPower"]; ok {
			if n, ok := v.(int64); ok {
				entry.MinPower = n
			}
		}
		if v, ok := m["maxPower"]; ok {
			if n, ok := v.(int64); ok {
				entry.MaxPower = n
			}
		}
		result = append(result, entry)
	}
	return result, true
}

// SetPlanID sets the unique plan identifier.
func (p *Plan) SetPlanID(planId uint32) error {
	attr, err := p.GetAttribute(PlanAttrPlanID)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(planId)
}

// SetPlanVersion sets the increments on each plan update.
func (p *Plan) SetPlanVersion(planVersion uint32) error {
	attr, err := p.GetAttribute(PlanAttrPlanVersion)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(planVersion)
}

// SetCommitment sets the how firm this plan is.
func (p *Plan) SetCommitment(commitment Commitment) error {
	attr, err := p.GetAttribute(PlanAttrCommitment)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(uint8(commitment))
}

// SetStartTime sets the when the plan starts (Unix timestamp).
func (p *Plan) SetStartTime(startTime uint64) error {
	attr, err := p.GetAttribute(PlanAttrStartTime)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(startTime)
}

// ClearStartTime clears the when the plan starts (Unix timestamp).
func (p *Plan) ClearStartTime() error {
	attr, err := p.GetAttribute(PlanAttrStartTime)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetStartTimePtr sets or clears the when the plan starts (Unix timestamp) from a pointer.
func (p *Plan) SetStartTimePtr(v *uint64) error {
	if v == nil {
		return p.ClearStartTime()
	}
	return p.SetStartTime(*v)
}

// SetEndTime sets the when the plan ends (Unix timestamp).
func (p *Plan) SetEndTime(endTime uint64) error {
	attr, err := p.GetAttribute(PlanAttrEndTime)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(endTime)
}

// ClearEndTime clears the when the plan ends (Unix timestamp).
func (p *Plan) ClearEndTime() error {
	attr, err := p.GetAttribute(PlanAttrEndTime)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetEndTimePtr sets or clears the when the plan ends (Unix timestamp) from a pointer.
func (p *Plan) SetEndTimePtr(v *uint64) error {
	if v == nil {
		return p.ClearEndTime()
	}
	return p.SetEndTime(*v)
}

// SetTotalEnergyPlanned sets the total planned energy (positive=consumption, negative=production).
func (p *Plan) SetTotalEnergyPlanned(totalEnergyPlanned int64) error {
	attr, err := p.GetAttribute(PlanAttrTotalEnergyPlanned)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(totalEnergyPlanned)
}

// ClearTotalEnergyPlanned clears the total planned energy (positive=consumption, negative=production).
func (p *Plan) ClearTotalEnergyPlanned() error {
	attr, err := p.GetAttribute(PlanAttrTotalEnergyPlanned)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// SetTotalEnergyPlannedPtr sets or clears the total planned energy (positive=consumption, negative=production) from a pointer.
func (p *Plan) SetTotalEnergyPlannedPtr(v *int64) error {
	if v == nil {
		return p.ClearTotalEnergyPlanned()
	}
	return p.SetTotalEnergyPlanned(*v)
}

// SetSlots sets the planned power behavior slots.
func (p *Plan) SetSlots(slots []PlanSlot) error {
	attr, err := p.GetAttribute(PlanAttrSlots)
	if err != nil {
		return err
	}
	if slots == nil {
		return attr.SetValueInternal(nil)
	}
	data := make([]any, len(slots))
	for i, item := range slots {
		data[i] = map[string]any{
			"duration":     item.Duration,
			"plannedPower": item.PlannedPower,
			"minPower":     item.MinPower,
			"maxPower":     item.MaxPower,
		}
	}
	return attr.SetValueInternal(data)
}

// ClearSlots clears the planned power behavior slots.
func (p *Plan) ClearSlots() error {
	attr, err := p.GetAttribute(PlanAttrSlots)
	if err != nil {
		return err
	}
	return attr.SetValueInternal(nil)
}

// Plan command IDs.
const (
	PlanCmdRequestPlan uint8 = 1
	PlanCmdAcceptPlan  uint8 = 2
)

// RequestPlanRequest represents the requestPlan command parameters.
type RequestPlanRequest struct {
	StartTime *uint64
	Duration  *uint32
}

// RequestPlanResponse represents the requestPlan command response.
type RequestPlanResponse struct {
	PlanID uint32
}

// AcceptPlanRequest represents the acceptPlan command parameters.
type AcceptPlanRequest struct {
	PlanID      uint32
	PlanVersion uint32
}

// AcceptPlanResponse represents the acceptPlan command response.
type AcceptPlanResponse struct {
	NewCommitment Commitment
}

// addCommands adds the Plan commands.
func (p *Plan) addCommands() {
	p.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          PlanCmdRequestPlan,
		Name:        "requestPlan",
		Description: "Request device to generate/update its plan",
		Parameters: []model.ParameterMetadata{
			{Name: "startTime", Type: model.DataTypeUint64, Required: false},
			{Name: "duration", Type: model.DataTypeUint32, Required: false},
		},
	}, p.handleRequestPlan))

	p.AddCommand(model.NewCommand(&model.CommandMetadata{
		ID:          PlanCmdAcceptPlan,
		Name:        "acceptPlan",
		Description: "Accept a plan, advancing its commitment level",
		Parameters: []model.ParameterMetadata{
			{Name: "planId", Type: model.DataTypeUint32, Required: true},
			{Name: "planVersion", Type: model.DataTypeUint32, Required: true},
		},
	}, p.handleAcceptPlan))

}

func (p *Plan) handleRequestPlan(ctx context.Context, params map[string]any) (map[string]any, error) {
	if p.onRequestPlan == nil {
		return map[string]any{"success": false}, nil
	}

	req := RequestPlanRequest{}
	if raw, exists := params["startTime"]; exists {
		if v, ok := raw.(uint64); ok {
			req.StartTime = &v
		}
	}
	if raw, exists := params["duration"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.Duration = &v
		}
	}

	resp, err := p.onRequestPlan(ctx, req)
	if err != nil {
		return nil, err
	}

	result := make(map[string]any)
	result["planId"] = resp.PlanID
	return result, nil
}

func (p *Plan) handleAcceptPlan(ctx context.Context, params map[string]any) (map[string]any, error) {
	if p.onAcceptPlan == nil {
		return map[string]any{"success": false}, nil
	}

	req := AcceptPlanRequest{}
	if raw, exists := params["planId"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.PlanID = v
		}
	}
	if raw, exists := params["planVersion"]; exists {
		if v, ok := wire.ToUint32(raw); ok {
			req.PlanVersion = v
		}
	}

	resp, err := p.onAcceptPlan(ctx, req)
	if err != nil {
		return nil, err
	}

	result := make(map[string]any)
	result["newCommitment"] = uint8(resp.NewCommitment)
	return result, nil
}

// OnRequestPlan sets the handler for requestPlan command.
func (p *Plan) OnRequestPlan(handler func(ctx context.Context, req RequestPlanRequest) (RequestPlanResponse, error)) {
	p.onRequestPlan = handler
}

// OnAcceptPlan sets the handler for acceptPlan command.
func (p *Plan) OnAcceptPlan(handler func(ctx context.Context, req AcceptPlanRequest) (AcceptPlanResponse, error)) {
	p.onAcceptPlan = handler
}
