package main

import (
	"fmt"
	"strings"
	"unicode"

	"github.com/mash-protocol/mash-go/pkg/specparse"
)

// GenerateFeature produces the full generated Go source for a feature.
func GenerateFeature(def *specparse.RawFeatureDef, shared *specparse.RawSharedTypes) (string, error) {
	var b strings.Builder

	b.WriteString("// Code generated by mash-featgen. DO NOT EDIT.\n\n")
	b.WriteString("package features\n\n")

	generateConstants(&b, def)
	generateEnums(&b, def.Enums, "")
	generateArrayStructs(&b, def)
	generateStruct(&b, def)
	generateConstructor(&b, def, shared)
	generateGetters(&b, def)
	generateSetters(&b, def)

	if len(def.Commands) > 0 {
		generateCommandConstants(&b, def)
		generateCommandStructs(&b, def)
		generateAddCommands(&b, def)
		generateCommandHandlers(&b, def)
		generateCallbackSetters(&b, def)
	}

	return b.String(), nil
}

// GenerateSharedEnums produces Go source for shared enum types.
func GenerateSharedEnums(shared *specparse.RawSharedTypes) (string, error) {
	var b strings.Builder

	b.WriteString("// Code generated by mash-featgen. DO NOT EDIT.\n\n")
	b.WriteString("package features\n\n")

	generateEnums(&b, shared.Enums, "")

	return b.String(), nil
}

// ValidateFeatureIDs checks that loaded feature definitions are consistent with the
// feature_types registry. Each feature must have a matching registry entry with the same ID.
func ValidateFeatureIDs(types []specparse.RawModelTypeDef, defs []*specparse.RawFeatureDef) error {
	registry := make(map[string]int, len(types))
	for _, t := range types {
		registry[t.Name] = t.ID
	}

	var errs []string
	for _, def := range defs {
		regID, ok := registry[def.Name]
		if !ok {
			errs = append(errs, fmt.Sprintf("feature %q loaded but no entry in feature_types registry", def.Name))
			continue
		}
		if regID != int(def.ID) {
			errs = append(errs, fmt.Sprintf("feature %q: YAML id=0x%02X but registry id=0x%02X", def.Name, def.ID, regID))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("feature ID validation errors:\n  %s", strings.Join(errs, "\n  "))
	}
	return nil
}

// GenerateFeatureTypes produces the generated Go source for FeatureType constants.
func GenerateFeatureTypes(types []specparse.RawModelTypeDef) (string, error) {
	var b strings.Builder
	renderTemplate(&b, "featureTypes", modelTypeData{Types: types})
	return b.String(), nil
}

// GenerateEndpointTypes produces the generated Go source for EndpointType constants.
func GenerateEndpointTypes(types []specparse.RawModelTypeDef) (string, error) {
	var b strings.Builder
	renderTemplate(&b, "endpointTypes", modelTypeData{Types: types})
	return b.String(), nil
}

// generateConstants writes attribute ID constants and revision constant.
func generateConstants(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "constants", def)
}

// generateEnums writes enum type definitions with const blocks and String() methods.
func generateEnums(b *strings.Builder, enums []specparse.RawEnumDef, prefix string) {
	renderTemplate(b, "enums", enumsData{Prefix: prefix, Enums: enums})
}

// generateArrayStructs writes struct definitions for object array items.
func generateArrayStructs(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "arrayStructs", def)
}

// generateStruct writes the feature struct definition.
func generateStruct(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "featureStruct", def)
}

// generateConstructor writes the NewXxx() constructor function.
func generateConstructor(b *strings.Builder, def *specparse.RawFeatureDef, shared *specparse.RawSharedTypes) {
	allEnums := buildEnumLookup(def, shared)

	attrs := make([]constructorAttrData, len(def.Attributes))
	for i, attr := range def.Attributes {
		attrs[i] = constructorAttrData{
			ConstName:   def.Name + "Attr" + goTitleCase(attr.Name),
			Name:        attr.Name,
			DataType:    modelDataType(attr.Type),
			Access:      accessConst(attr.Access),
			Nullable:    attr.Nullable,
			Unit:        attr.Unit,
			Description: attr.Description,
		}
		if attr.Default != nil {
			attrs[i].DefaultExpr = defaultValueExpr(attr, allEnums)
		}
		if attr.Min != nil {
			attrs[i].MinExpr = typedLiteral(attr.Type, attr.Min)
		}
		if attr.Max != nil {
			attrs[i].MaxExpr = typedLiteral(attr.Type, attr.Max)
		}
	}

	renderTemplate(b, "constructor", constructorData{
		Name:             def.Name,
		FeatureTypeConst: "model.Feature" + def.Name,
		Attributes:       attrs,
		HasCommands:      len(def.Commands) > 0,
	})
}

// generateGetters writes typed getter methods.
func generateGetters(b *strings.Builder, def *specparse.RawFeatureDef) {
	name := def.Name
	recv := strings.ToLower(name[:1])

	for _, attr := range def.Attributes {
		methodName := goTitleCase(attr.Name)
		constName := name + "Attr" + methodName

		if attr.Enum != "" {
			enumType := attr.Enum
			if attr.Nullable {
				fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s() (%s, bool) {\n", recv, name, methodName, enumType)
				fmt.Fprintf(b, "val, err := %s.ReadAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if err != nil || val == nil {\n")
				fmt.Fprintf(b, "return 0, false\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "if v, ok := val.(%s); ok {\n", goTypeName(attr.Type))
				fmt.Fprintf(b, "return %s(v), true\n", enumType)
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "return 0, false\n")
				fmt.Fprintf(b, "}\n\n")
			} else {
				defaultVal := enumDefaultConst(attr, def)
				fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s() %s {\n", recv, name, methodName, enumType)
				fmt.Fprintf(b, "val, _ := %s.ReadAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if v, ok := val.(%s); ok {\n", goTypeName(attr.Type))
				fmt.Fprintf(b, "return %s(v)\n", enumType)
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "return %s\n", defaultVal)
				fmt.Fprintf(b, "}\n\n")
			}
		} else if attr.Type == "map" {
			goKey := attr.MapKeyType
			goVal := goTypeName(attr.MapValueType)
			mapType := fmt.Sprintf("map[%s]%s", goKey, goVal)

			fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s() (%s, bool) {\n", recv, name, methodName, mapType)
			fmt.Fprintf(b, "val, err := %s.ReadAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if err != nil || val == nil {\n")
			fmt.Fprintf(b, "return nil, false\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "if v, ok := val.(%s); ok {\n", mapType)
			fmt.Fprintf(b, "return v, true\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return nil, false\n")
			fmt.Fprintf(b, "}\n\n")
		} else if attr.Type == "array" {
			if attr.Items == nil {
				continue
			}
			if attr.Items.Type == "object" {
				structType := attr.Items.StructName
				fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s() ([]%s, bool) {\n", recv, name, methodName, structType)
				fmt.Fprintf(b, "val, err := %s.ReadAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if err != nil || val == nil {\n")
				fmt.Fprintf(b, "return nil, false\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "raw, ok := val.([]any)\n")
				fmt.Fprintf(b, "if !ok {\n")
				fmt.Fprintf(b, "return nil, false\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "result := make([]%s, 0, len(raw))\n", structType)
				fmt.Fprintf(b, "for _, item := range raw {\n")
				fmt.Fprintf(b, "m, ok := item.(map[string]any)\n")
				fmt.Fprintf(b, "if !ok {\n")
				fmt.Fprintf(b, "continue\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "entry := %s{}\n", structType)
				for _, field := range attr.Items.Fields {
					fieldTitle := goTitleCase(field.Name)
					if field.Enum != "" {
						fmt.Fprintf(b, "if v, ok := m[%q]; ok {\n", field.Name)
						fmt.Fprintf(b, "if n, ok := v.(%s); ok {\n", goTypeName(field.Type))
						fmt.Fprintf(b, "entry.%s = %s(n)\n", fieldTitle, field.Enum)
						fmt.Fprintf(b, "}\n")
						fmt.Fprintf(b, "}\n")
					} else {
						goType := goTypeName(field.Type)
						fmt.Fprintf(b, "if v, ok := m[%q]; ok {\n", field.Name)
						fmt.Fprintf(b, "if n, ok := v.(%s); ok {\n", goType)
						fmt.Fprintf(b, "entry.%s = n\n", fieldTitle)
						fmt.Fprintf(b, "}\n")
						fmt.Fprintf(b, "}\n")
					}
				}
				fmt.Fprintf(b, "result = append(result, entry)\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "return result, true\n")
				fmt.Fprintf(b, "}\n\n")
			} else if attr.Items.Enum != "" {
				enumType := attr.Items.Enum
				fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s() ([]%s, bool) {\n", recv, name, methodName, enumType)
				fmt.Fprintf(b, "val, err := %s.ReadAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if err != nil || val == nil {\n")
				fmt.Fprintf(b, "return nil, false\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "raw, ok := val.([]any)\n")
				fmt.Fprintf(b, "if !ok {\n")
				fmt.Fprintf(b, "return nil, false\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "result := make([]%s, 0, len(raw))\n", enumType)
				fmt.Fprintf(b, "for _, item := range raw {\n")
				fmt.Fprintf(b, "if v, ok := item.(%s); ok {\n", goTypeName(attr.Items.Type))
				fmt.Fprintf(b, "result = append(result, %s(v))\n", enumType)
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "return result, true\n")
				fmt.Fprintf(b, "}\n\n")
			}
			continue
		} else if attr.Nullable {
			goType := goTypeName(attr.Type)
			zeroVal := goZeroValue(attr.Type)

			fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s() (%s, bool) {\n", recv, name, methodName, goType)
			fmt.Fprintf(b, "val, err := %s.ReadAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if err != nil || val == nil {\n")
			fmt.Fprintf(b, "return %s, false\n", zeroVal)
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "if v, ok := val.(%s); ok {\n", goType)
			fmt.Fprintf(b, "return v, true\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return %s, false\n", zeroVal)
			fmt.Fprintf(b, "}\n\n")
		} else if attr.Type == "string" {
			fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s() string {\n", recv, name, methodName)
			fmt.Fprintf(b, "val, _ := %s.ReadAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if v, ok := val.(string); ok {\n")
			fmt.Fprintf(b, "return v\n")
			fmt.Fprintf(b, "}\n")
			defaultStr := ""
			if attr.Default != nil {
				if s, ok := attr.Default.(string); ok {
					defaultStr = s
				}
			}
			fmt.Fprintf(b, "return %q\n", defaultStr)
			fmt.Fprintf(b, "}\n\n")
		} else if attr.Type == "bool" {
			fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s() bool {\n", recv, name, methodName)
			fmt.Fprintf(b, "val, _ := %s.ReadAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if v, ok := val.(bool); ok {\n")
			fmt.Fprintf(b, "return v\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return false\n")
			fmt.Fprintf(b, "}\n\n")
		} else {
			goType := goTypeName(attr.Type)
			defaultVal := goZeroValue(attr.Type)
			if attr.Default != nil {
				defaultVal = typedLiteral(attr.Type, attr.Default)
			}

			fmt.Fprintf(b, "// %s returns the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s() %s {\n", recv, name, methodName, goType)
			fmt.Fprintf(b, "val, _ := %s.ReadAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if v, ok := val.(%s); ok {\n", goType)
			fmt.Fprintf(b, "return v\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return %s\n", defaultVal)
			fmt.Fprintf(b, "}\n\n")
		}
	}
}

// generateSetters writes typed setter methods.
func generateSetters(b *strings.Builder, def *specparse.RawFeatureDef) {
	name := def.Name
	recv := strings.ToLower(name[:1])

	for _, attr := range def.Attributes {
		methodName := "Set" + goTitleCase(attr.Name)
		constName := name + "Attr" + goTitleCase(attr.Name)

		if attr.Type == "array" {
			if attr.Items == nil {
				continue
			}
			if attr.Items.Type == "object" {
				structType := attr.Items.StructName
				paramName := firstLowerIdent(attr.Name)
				fmt.Fprintf(b, "// %s sets the %s.\n", methodName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s(%s []%s) error {\n", recv, name, methodName, paramName, structType)
				fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if err != nil {\n")
				fmt.Fprintf(b, "return err\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "if %s == nil {\n", paramName)
				fmt.Fprintf(b, "return attr.SetValueInternal(nil)\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "data := make([]any, len(%s))\n", paramName)
				fmt.Fprintf(b, "for i, item := range %s {\n", paramName)
				b.WriteString("data[i] = map[string]any{\n")
				for _, field := range attr.Items.Fields {
					fieldTitle := goTitleCase(field.Name)
					if field.Enum != "" {
						fmt.Fprintf(b, "%q: %s(item.%s),\n", field.Name, goTypeName(field.Type), fieldTitle)
					} else {
						fmt.Fprintf(b, "%q: item.%s,\n", field.Name, fieldTitle)
					}
				}
				b.WriteString("}\n")
				b.WriteString("}\n")
				fmt.Fprintf(b, "return attr.SetValueInternal(data)\n")
				fmt.Fprintf(b, "}\n\n")
			} else if attr.Items.Enum != "" {
				enumType := attr.Items.Enum
				paramName := firstLowerIdent(attr.Name)
				fmt.Fprintf(b, "// %s sets the %s.\n", methodName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s(%s []%s) error {\n", recv, name, methodName, paramName, enumType)
				fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if err != nil {\n")
				fmt.Fprintf(b, "return err\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "data := make([]%s, len(%s))\n", goTypeName(attr.Items.Type), paramName)
				fmt.Fprintf(b, "for i, v := range %s {\n", paramName)
				fmt.Fprintf(b, "data[i] = %s(v)\n", goTypeName(attr.Items.Type))
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "return attr.SetValueInternal(data)\n")
				fmt.Fprintf(b, "}\n\n")
			}

			if attr.Nullable && attr.Items != nil {
				clearName := "Clear" + goTitleCase(attr.Name)
				fmt.Fprintf(b, "// %s clears the %s.\n", clearName, firstLower(attr.Description))
				fmt.Fprintf(b, "func (%s *%s) %s() error {\n", recv, name, clearName)
				fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
				fmt.Fprintf(b, "if err != nil {\n")
				fmt.Fprintf(b, "return err\n")
				fmt.Fprintf(b, "}\n")
				fmt.Fprintf(b, "return attr.SetValueInternal(nil)\n")
				fmt.Fprintf(b, "}\n\n")
			}

			continue
		}

		if attr.Enum != "" {
			enumType := attr.Enum
			paramName := firstLowerIdent(attr.Name)
			fmt.Fprintf(b, "// %s sets the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s(%s %s) error {\n", recv, name, methodName, paramName, enumType)
			fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if err != nil {\n")
			fmt.Fprintf(b, "return err\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return attr.SetValueInternal(%s(%s))\n", goTypeName(attr.Type), paramName)
			fmt.Fprintf(b, "}\n\n")
		} else if attr.Type == "map" {
			goKey := attr.MapKeyType
			goVal := goTypeName(attr.MapValueType)
			mapType := fmt.Sprintf("map[%s]%s", goKey, goVal)
			paramName := firstLowerIdent(attr.Name)

			fmt.Fprintf(b, "// %s sets the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s(%s %s) error {\n", recv, name, methodName, paramName, mapType)
			fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if err != nil {\n")
			fmt.Fprintf(b, "return err\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return attr.SetValueInternal(%s)\n", paramName)
			fmt.Fprintf(b, "}\n\n")
		} else {
			goType := goTypeName(attr.Type)
			paramName := firstLowerIdent(attr.Name)

			fmt.Fprintf(b, "// %s sets the %s.\n", methodName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s(%s %s) error {\n", recv, name, methodName, paramName, goType)
			fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if err != nil {\n")
			fmt.Fprintf(b, "return err\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return attr.SetValueInternal(%s)\n", paramName)
			fmt.Fprintf(b, "}\n\n")
		}

		if attr.Nullable {
			clearName := "Clear" + goTitleCase(attr.Name)
			fmt.Fprintf(b, "// %s clears the %s.\n", clearName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s() error {\n", recv, name, clearName)
			fmt.Fprintf(b, "attr, err := %s.GetAttribute(%s)\n", recv, constName)
			fmt.Fprintf(b, "if err != nil {\n")
			fmt.Fprintf(b, "return err\n")
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return attr.SetValueInternal(nil)\n")
			fmt.Fprintf(b, "}\n\n")

			attrTitle := goTitleCase(attr.Name)
			ptrName := "Set" + attrTitle + "Ptr"
			var ptrType string
			if attr.Enum != "" {
				ptrType = "*" + attr.Enum
			} else if attr.Type == "map" {
				ptrType = "*" + fmt.Sprintf("map[%s]%s", attr.MapKeyType, goTypeName(attr.MapValueType))
			} else {
				ptrType = "*" + goTypeName(attr.Type)
			}
			fmt.Fprintf(b, "// %s sets or clears the %s from a pointer.\n", ptrName, firstLower(attr.Description))
			fmt.Fprintf(b, "func (%s *%s) %s(v %s) error {\n", recv, name, ptrName, ptrType)
			fmt.Fprintf(b, "if v == nil {\n")
			fmt.Fprintf(b, "return %s.%s()\n", recv, clearName)
			fmt.Fprintf(b, "}\n")
			fmt.Fprintf(b, "return %s.Set%s(*v)\n", recv, attrTitle)
			fmt.Fprintf(b, "}\n\n")
		}
	}
}

// --- Command generation ---

func generateCommandConstants(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "commandConstants", def)
}

func generateCommandStructs(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "commandStructs", def)
}

func generateAddCommands(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "addCommands", def)
}

func generateCommandHandlers(b *strings.Builder, def *specparse.RawFeatureDef) {
	name := def.Name
	recv := strings.ToLower(name[:1])

	for _, cmd := range def.Commands {
		handlerName := "handle" + goTitleCase(cmd.Name)
		callbackField := "on" + goTitleCase(cmd.Name)
		simple := isSimpleResponse(cmd)
		hasParams := hasParameters(cmd)

		fmt.Fprintf(b, "func (%s *%s) %s(ctx context.Context, params map[string]any) (map[string]any, error) {\n",
			recv, name, handlerName)

		fmt.Fprintf(b, "if %s.%s == nil {\n", recv, callbackField)
		writeNilHandlerDefault(b, cmd)
		b.WriteString("}\n\n")

		if hasParams {
			reqType := goTitleCase(cmd.Name) + "Request"
			fmt.Fprintf(b, "req := %s{}\n", reqType)
			for _, p := range cmd.Parameters {
				fieldName := goTitleCase(p.Name)
				fmt.Fprintf(b, "if raw, exists := params[%q]; exists {\n", p.Name)
				writeParamParse(b, p, fieldName, "req")
				b.WriteString("}\n")
			}
			b.WriteString("\n")
		}

		if simple {
			if hasParams {
				fmt.Fprintf(b, "err := %s.%s(ctx, req)\n", recv, callbackField)
			} else {
				fmt.Fprintf(b, "err := %s.%s(ctx)\n", recv, callbackField)
			}
			fmt.Fprintf(b, "return map[string]any{\"success\": err == nil}, err\n")
		} else {
			if hasParams {
				fmt.Fprintf(b, "resp, err := %s.%s(ctx, req)\n", recv, callbackField)
			} else {
				fmt.Fprintf(b, "resp, err := %s.%s(ctx)\n", recv, callbackField)
			}
			fmt.Fprintf(b, "if err != nil {\n")
			fmt.Fprintf(b, "return nil, err\n")
			fmt.Fprintf(b, "}\n\n")

			writeResponseSerialize(b, cmd, recv)
		}

		b.WriteString("}\n\n")
	}
}

func writeNilHandlerDefault(b *strings.Builder, cmd specparse.RawCommandDef) {
	if !isSimpleResponse(cmd) {
		hasApplied := false
		for _, r := range cmd.Response {
			if r.Name == "applied" {
				hasApplied = true
				break
			}
		}
		if hasApplied {
			fmt.Fprintf(b, "return map[string]any{\"applied\": false}, nil\n")
		} else {
			fmt.Fprintf(b, "return map[string]any{\"success\": false}, nil\n")
		}
	} else {
		fmt.Fprintf(b, "return map[string]any{\"success\": false}, nil\n")
	}
}

func writeResponseSerialize(b *strings.Builder, cmd specparse.RawCommandDef, recv string) {
	b.WriteString("result := make(map[string]any)\n")
	for _, r := range cmd.Response {
		fieldName := goTitleCase(r.Name)
		if r.Required {
			if r.Enum != "" {
				fmt.Fprintf(b, "result[%q] = uint8(resp.%s)\n", r.Name, fieldName)
			} else {
				fmt.Fprintf(b, "result[%q] = resp.%s\n", r.Name, fieldName)
			}
		} else {
			fmt.Fprintf(b, "if resp.%s != nil {\n", fieldName)
			if r.Enum != "" {
				fmt.Fprintf(b, "result[%q] = uint8(*resp.%s)\n", r.Name, fieldName)
			} else {
				fmt.Fprintf(b, "result[%q] = *resp.%s\n", r.Name, fieldName)
			}
			b.WriteString("}\n")
		}
	}
	b.WriteString("return result, nil\n")
}

func writeParamParse(b *strings.Builder, p specparse.RawParameterDef, fieldName, structVar string) {
	wireFunc := wireCoercionFunc(p.Type)
	if wireFunc != "" {
		fmt.Fprintf(b, "if v, ok := %s(raw); ok {\n", wireFunc)
		if p.Enum != "" && !p.Required {
			fmt.Fprintf(b, "tmp := %s(v)\n", p.Enum)
			fmt.Fprintf(b, "%s.%s = &tmp\n", structVar, fieldName)
		} else if p.Enum != "" {
			fmt.Fprintf(b, "%s.%s = %s(v)\n", structVar, fieldName, p.Enum)
		} else if !p.Required {
			fmt.Fprintf(b, "%s.%s = &v\n", structVar, fieldName)
		} else {
			fmt.Fprintf(b, "%s.%s = v\n", structVar, fieldName)
		}
		b.WriteString("}\n")
	} else if p.Type == "map" {
		fmt.Fprintf(b, "if v, ok := raw.(map[string]any); ok {\n")
		fmt.Fprintf(b, "%s.%s = v\n", structVar, fieldName)
		b.WriteString("}\n")
	} else {
		goType := goTypeName(p.Type)
		fmt.Fprintf(b, "if v, ok := raw.(%s); ok {\n", goType)
		if !p.Required {
			fmt.Fprintf(b, "%s.%s = &v\n", structVar, fieldName)
		} else {
			fmt.Fprintf(b, "%s.%s = v\n", structVar, fieldName)
		}
		b.WriteString("}\n")
	}
}

func generateCallbackSetters(b *strings.Builder, def *specparse.RawFeatureDef) {
	renderTemplate(b, "callbackSetters", def)
}

// isSimpleResponse returns true if the command has no response fields or only a
// single required bool field named "success".
func isSimpleResponse(cmd specparse.RawCommandDef) bool {
	if len(cmd.Response) == 0 {
		return true
	}
	if len(cmd.Response) == 1 && cmd.Response[0].Name == "success" && cmd.Response[0].Type == "bool" && cmd.Response[0].Required {
		return true
	}
	return false
}

// hasParameters returns true if the command has parameters.
func hasParameters(cmd specparse.RawCommandDef) bool {
	return len(cmd.Parameters) > 0
}

// typedHandlerType returns the Go typed function signature for a command handler callback.
func typedHandlerType(cmd specparse.RawCommandDef) string {
	hasParams := hasParameters(cmd)
	simple := isSimpleResponse(cmd)

	cmdName := goTitleCase(cmd.Name)

	switch {
	case !hasParams && simple:
		return "func(ctx context.Context) error"
	case hasParams && simple:
		return "func(ctx context.Context, req " + cmdName + "Request) error"
	case !hasParams && !simple:
		return "func(ctx context.Context) (" + cmdName + "Response, error)"
	default: // hasParams && !simple
		return "func(ctx context.Context, req " + cmdName + "Request) (" + cmdName + "Response, error)"
	}
}

// commandHandlerType returns the Go type for a command handler callback.
func commandHandlerType(cmd specparse.RawCommandDef) string {
	return typedHandlerType(cmd)
}

func commandFieldType(p specparse.RawParameterDef) string {
	baseType := goTypeName(p.Type)
	if p.Enum != "" {
		baseType = p.Enum
	}
	// Bare "map" in command params means map[string]any (wire format)
	if baseType == "map" {
		baseType = "map[string]any"
	}
	if !p.Required {
		return "*" + baseType
	}
	return baseType
}

// --- Helper functions ---

// knownInitialisms is the set of abbreviations that should be all-uppercase in Go identifiers.
var knownInitialisms = map[string]bool{
	"AC": true, "DC": true, "EV": true, "ID": true, "PV": true,
	"AB": true, "BC": true, "CA": true,
	"EVSE": true, "EVCC": true, "PCID": true,
	"MAC": true, "EUI": true, "RFID": true, "VIN": true,
	"HVAC": true,
}

// toEndpointGoName converts a SCREAMING_SNAKE endpoint name to a Go constant name.
// E.g. "EV_CHARGER" -> "EndpointEVCharger", "HVAC" -> "EndpointHVAC".
func toEndpointGoName(screaming string) string {
	return "Endpoint" + enumValueSuffix(screaming)
}

// splitCamelCase splits a camelCase string into its constituent words.
// E.g. "acActivePower" -> ["ac", "Active", "Power"]
func splitCamelCase(s string) []string {
	if s == "" {
		return []string{}
	}

	var words []string
	runes := []rune(s)
	start := 0
	for i := 1; i < len(runes); i++ {
		if unicode.IsUpper(runes[i]) {
			words = append(words, string(runes[start:i]))
			start = i
		}
	}
	words = append(words, string(runes[start:]))
	return words
}

// goTitleCase converts camelCase to Go PascalCase with proper initialisms.
// E.g. "acActivePower" -> "ACActivePower", "deviceId" -> "DeviceID"
func goTitleCase(s string) string {
	if s == "" {
		return ""
	}

	words := splitCamelCase(s)
	var result strings.Builder
	for _, word := range words {
		upper := strings.ToUpper(word)
		if knownInitialisms[upper] {
			result.WriteString(upper)
		} else {
			runes := []rune(word)
			runes[0] = unicode.ToUpper(runes[0])
			result.WriteString(string(runes))
		}
	}
	return result.String()
}

// firstLower converts "Current operating state" to "current operating state".
func firstLower(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

// firstLowerIdent returns a parameter name from an attribute name.
func firstLowerIdent(s string) string {
	if s == "" {
		return s
	}
	// Already camelCase, just return as-is
	return s
}

// enumValueSuffix converts "UNKNOWN" to "Unknown", "SHUTTING_DOWN" to "ShuttingDown".
// It is initialism-aware: "PCID" -> "PCID", "MAC_EUI48" -> "MACEUI48", "CONTRACT_ID" -> "ContractID".
func enumValueSuffix(name string) string {
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) == 0 {
			continue
		}
		// Separate trailing digits from alphabetic base
		alphaEnd := len(part)
		for alphaEnd > 0 && part[alphaEnd-1] >= '0' && part[alphaEnd-1] <= '9' {
			alphaEnd--
		}
		alpha := part[:alphaEnd]
		digits := part[alphaEnd:]

		if alpha != "" && knownInitialisms[alpha] {
			result.WriteString(alpha)
		} else {
			result.WriteString(strings.ToUpper(part[:1]))
			if len(part) > 1 {
				result.WriteString(strings.ToLower(part[1:]))
			}
			continue // digits already included in the lowercase tail
		}
		result.WriteString(digits)
	}
	return result.String()
}

// goTypeName converts YAML type strings to Go type names.
func goTypeName(yamlType string) string {
	switch yamlType {
	case "uint8":
		return "uint8"
	case "uint16":
		return "uint16"
	case "uint32":
		return "uint32"
	case "uint64":
		return "uint64"
	case "int8":
		return "int8"
	case "int16":
		return "int16"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "float32":
		return "float32"
	case "float64":
		return "float64"
	case "bool":
		return "bool"
	case "string":
		return "string"
	case "bytes":
		return "[]byte"
	case "array":
		return "[]any"
	case "map":
		return "map[string]any"
	default:
		return yamlType
	}
}

// modelDataType converts YAML type to model.DataTypeXxx constant.
func modelDataType(yamlType string) string {
	switch yamlType {
	case "uint8":
		return "model.DataTypeUint8"
	case "uint16":
		return "model.DataTypeUint16"
	case "uint32":
		return "model.DataTypeUint32"
	case "uint64":
		return "model.DataTypeUint64"
	case "int8":
		return "model.DataTypeInt8"
	case "int16":
		return "model.DataTypeInt16"
	case "int32":
		return "model.DataTypeInt32"
	case "int64":
		return "model.DataTypeInt64"
	case "float32":
		return "model.DataTypeFloat32"
	case "float64":
		return "model.DataTypeFloat64"
	case "bool":
		return "model.DataTypeBool"
	case "string":
		return "model.DataTypeString"
	case "bytes":
		return "model.DataTypeBytes"
	case "array":
		return "model.DataTypeArray"
	case "map":
		return "model.DataTypeMap"
	default:
		return "model.DataTypeUnknown"
	}
}

// accessConst converts YAML access to model.AccessXxx constant.
func accessConst(yamlAccess string) string {
	switch yamlAccess {
	case "readOnly":
		return "model.AccessReadOnly"
	case "readWrite":
		return "model.AccessReadWrite"
	case "read":
		return "model.AccessRead"
	default:
		return "model.AccessReadOnly"
	}
}

// wireCoercionFunc maps YAML type to wire.ToXxx coercion function name.
func wireCoercionFunc(yamlType string) string {
	switch yamlType {
	case "int64":
		return "wire.ToInt64"
	case "uint32":
		return "wire.ToUint32"
	case "uint8":
		return "wire.ToUint8Public"
	default:
		return ""
	}
}

// goZeroValue returns the zero value literal for a Go type.
func goZeroValue(yamlType string) string {
	switch yamlType {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
		return "0"
	case "float32", "float64":
		return "0"
	case "bool":
		return "false"
	case "string":
		return `""`
	default:
		return "nil"
	}
}

// typedLiteral converts a parsed YAML value to a typed Go literal.
func typedLiteral(yamlType string, val any) string {
	switch yamlType {
	case "uint8":
		return fmt.Sprintf("uint8(%v)", val)
	case "uint16":
		return fmt.Sprintf("uint16(%v)", val)
	case "uint32":
		return fmt.Sprintf("uint32(%v)", val)
	case "uint64":
		return fmt.Sprintf("uint64(%v)", val)
	case "int8":
		return fmt.Sprintf("int8(%v)", val)
	case "int16":
		return fmt.Sprintf("int16(%v)", val)
	case "int32":
		return fmt.Sprintf("int32(%v)", val)
	case "int64":
		return fmt.Sprintf("int64(%v)", val)
	case "float32":
		return fmt.Sprintf("float32(%v)", val)
	case "float64":
		return fmt.Sprintf("float64(%v)", val)
	case "bool":
		return fmt.Sprintf("%v", val)
	case "string":
		return fmt.Sprintf("%q", val)
	default:
		return fmt.Sprintf("%v", val)
	}
}

// defaultValueExpr produces the Go expression for an attribute's default value.
func defaultValueExpr(attr specparse.RawAttributeDef, allEnums map[string]specparse.RawEnumDef) string {
	if attr.Default == nil {
		return "nil"
	}

	// If the attribute references an enum and the default is a string (enum value name),
	// resolve it to the typed constant.
	if attr.Enum != "" {
		if defStr, ok := attr.Default.(string); ok {
			enumDef, found := allEnums[attr.Enum]
			if found {
				for _, val := range enumDef.Values {
					if val.Name == defStr {
						constName := attr.Enum + enumValueSuffix(val.Name)
						return fmt.Sprintf("%s(%s)", goTypeName(attr.Type), constName)
					}
				}
			}
		}
	}

	return typedLiteral(attr.Type, attr.Default)
}

// enumDefaultConst returns the default enum constant for a getter's return value.
func enumDefaultConst(attr specparse.RawAttributeDef, def *specparse.RawFeatureDef) string {
	if attr.Default != nil {
		if defStr, ok := attr.Default.(string); ok {
			return attr.Enum + enumValueSuffix(defStr)
		}
	}
	// Fallback: first value
	for _, e := range def.Enums {
		if e.Name == attr.Enum && len(e.Values) > 0 {
			return attr.Enum + enumValueSuffix(e.Values[0].Name)
		}
	}
	return "0"
}

// buildEnumLookup creates a map of enum name -> definition from both feature and shared enums.
func buildEnumLookup(def *specparse.RawFeatureDef, shared *specparse.RawSharedTypes) map[string]specparse.RawEnumDef {
	lookup := make(map[string]specparse.RawEnumDef)
	if shared != nil {
		for _, e := range shared.Enums {
			lookup[e.Name] = e
		}
	}
	for _, e := range def.Enums {
		lookup[e.Name] = e
	}
	return lookup
}
