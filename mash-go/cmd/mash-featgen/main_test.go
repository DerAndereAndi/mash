package main

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/mash-protocol/mash-go/pkg/specparse"
)

var multiSpace = regexp.MustCompile(`\s+`)

// normalizeWS collapses runs of whitespace to a single space.
func normalizeWS(s string) string {
	return multiSpace.ReplaceAllString(s, " ")
}

func TestFeatureDirName(t *testing.T) {
	tests := []struct {
		in, want string
	}{
		{"DeviceInfo", "device-info"},
		{"Status", "status"},
		{"EnergyControl", "energy-control"},
		{"ChargingSession", "charging-session"},
		{"Electrical", "electrical"},
		{"Measurement", "measurement"},
	}
	for _, tt := range tests {
		got := specparse.FeatureDirName(tt.in)
		if got != tt.want {
			t.Errorf("FeatureDirName(%q) = %q, want %q", tt.in, got, tt.want)
		}
	}
}

func TestFeatureFileName(t *testing.T) {
	tests := []struct {
		in, want string
	}{
		{"DeviceInfo", "device_info"},
		{"Status", "status"},
		{"EnergyControl", "energy_control"},
		{"ChargingSession", "charging_session"},
	}
	for _, tt := range tests {
		got := featureFileName(tt.in)
		if got != tt.want {
			t.Errorf("featureFileName(%q) = %q, want %q", tt.in, got, tt.want)
		}
	}
}

func TestGeneratorEndToEnd(t *testing.T) {
	featDir := docsDir(t)
	sharedPath := filepath.Join(featDir, "_shared", "1.0.yaml")
	protocolPath := filepath.Join(featDir, "protocol-versions.yaml")

	tmpDir := t.TempDir()
	specOutput := filepath.Join(tmpDir, "spec.yaml")

	err := run(featDir, sharedPath, protocolPath, "1.0", tmpDir, "", specOutput)
	if err != nil {
		t.Fatalf("run failed: %v", err)
	}

	// Verify all *_gen.go files were created
	expectedFiles := []string{
		"shared_gen.go",
		"device_info_gen.go",
		"status_gen.go",
		"electrical_gen.go",
		"measurement_gen.go",
		"energy_control_gen.go",
		"charging_session_gen.go",
	}

	for _, f := range expectedFiles {
		path := filepath.Join(tmpDir, f)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			t.Errorf("expected file %s not created", f)
			continue
		}
		data, err := os.ReadFile(path)
		if err != nil {
			t.Errorf("reading %s: %v", f, err)
			continue
		}
		content := string(data)

		// All generated files should have the header
		if !strings.Contains(content, "// Code generated by mash-featgen. DO NOT EDIT.") {
			t.Errorf("%s missing generated header", f)
		}
		if !strings.Contains(content, "package features") {
			t.Errorf("%s missing package declaration", f)
		}
	}

	// Verify spec manifest was created
	if _, err := os.Stat(specOutput); os.IsNotExist(err) {
		t.Fatal("spec manifest not created")
	}
	specData, err := os.ReadFile(specOutput)
	if err != nil {
		t.Fatalf("reading spec manifest: %v", err)
	}
	specContent := string(specData)

	// Verify spec manifest contains all 6 features
	for _, feature := range []string{"DeviceInfo", "Status", "Electrical", "Measurement", "EnergyControl", "ChargingSession"} {
		if !strings.Contains(specContent, feature+":") {
			t.Errorf("spec manifest missing feature %s", feature)
		}
	}
}

func TestGenerateStatus_ContentCheck(t *testing.T) {
	featDir := docsDir(t)
	sharedPath := filepath.Join(featDir, "_shared", "1.0.yaml")
	protocolPath := filepath.Join(featDir, "protocol-versions.yaml")

	tmpDir := t.TempDir()

	err := run(featDir, sharedPath, protocolPath, "1.0", tmpDir, "", "")
	if err != nil {
		t.Fatalf("run failed: %v", err)
	}

	data, err := os.ReadFile(filepath.Join(tmpDir, "status_gen.go"))
	if err != nil {
		t.Fatalf("reading status_gen.go: %v", err)
	}
	content := string(data)

	// Verify key elements of the generated Status feature
	checks := []string{
		"StatusAttrOperatingState uint16 = 1",
		"StatusAttrStateDetail uint16 = 2",
		"const StatusFeatureRevision uint16 = 1",
		"type OperatingState uint8",
		"OperatingStateUnknown OperatingState = 0x00",
		"type Status struct {",
		"*model.Feature",
		"func NewStatus() *Status {",
		"model.NewFeature(model.FeatureStatus, StatusFeatureRevision)",
		"func (s *Status) OperatingState() OperatingState {",
		"func (s *Status) SetOperatingState(operatingState OperatingState) error {",
		"func (s *Status) StateDetail() (uint32, bool) {",
		"func (s *Status) FaultMessage() (string, bool) {",
	}

	normalized := normalizeWS(content)
	for _, check := range checks {
		if !strings.Contains(normalized, normalizeWS(check)) {
			t.Errorf("status_gen.go missing: %q", check)
		}
	}
}
