package main

import (
	"path/filepath"
	"strings"
	"testing"

	"github.com/mash-protocol/mash-go/pkg/specparse"
)

func loadTestData(t *testing.T) ([]specparse.RawModelTypeDef, []specparse.RawModelTypeDef, []*specparse.RawFeatureDef) {
	t.Helper()
	featDir := docsDir(t)
	protocolPath := filepath.Join(featDir, "protocol-versions.yaml")

	pv, err := specparse.LoadProtocolVersions(protocolPath)
	if err != nil {
		t.Fatalf("loading protocol versions: %v", err)
	}

	ver := pv.Versions["1.0"]

	var allDefs []*specparse.RawFeatureDef
	for featureName, featureVer := range ver.Features {
		dirName := specparse.FeatureDirName(featureName)
		yamlPath := filepath.Join(featDir, dirName, featureVer+".yaml")
		def, err := specparse.LoadFeatureDef(yamlPath)
		if err != nil {
			t.Fatalf("loading feature %s: %v", featureName, err)
		}
		allDefs = append(allDefs, def)
	}

	return ver.EndpointTypes, ver.FeatureTypes, allDefs
}

func TestGenerateNameTables_Compiles(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	if !strings.Contains(code, "// Code generated by mash-featgen. DO NOT EDIT.") {
		t.Error("missing generated header")
	}
	if !strings.Contains(code, "package inspect") {
		t.Error("missing package declaration")
	}
}

func TestGenerateNameTables_EndpointNames(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	// All endpoint types should be present as lowercase keys
	expectedEndpoints := []struct {
		key, modelConst string
	}{
		{"deviceroot", "model.EndpointDeviceRoot"},
		{"gridconnection", "model.EndpointGridConnection"},
		{"inverter", "model.EndpointInverter"},
		{"pvstring", "model.EndpointPVString"},
		{"battery", "model.EndpointBattery"},
		{"evcharger", "model.EndpointEVCharger"},
		{"heatpump", "model.EndpointHeatPump"},
		{"waterheater", "model.EndpointWaterHeater"},
		{"hvac", "model.EndpointHVAC"},
		{"appliance", "model.EndpointAppliance"},
		{"submeter", "model.EndpointSubMeter"},
	}

	for _, ep := range expectedEndpoints {
		needle := `"` + ep.key + `": uint8(` + ep.modelConst + `)`
		if !strings.Contains(code, needle) {
			t.Errorf("missing endpoint entry: %s", needle)
		}
	}
}

func TestGenerateNameTables_FeatureNames(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	expectedFeatures := []string{
		"electrical", "measurement", "energycontrol", "status",
		"deviceinfo", "chargingsession", "signals", "tariff",
		"plan", "testcontrol",
	}

	for _, feat := range expectedFeatures {
		if !strings.Contains(code, `"`+feat+`"`) {
			t.Errorf("missing feature entry: %s", feat)
		}
	}
}

func TestGenerateNameTables_AllFeaturesHaveAttributes(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	// Every feature should have an attribute table with global attributes
	for _, def := range allDefs {
		featureConst := "model.Feature" + def.Name
		needle := "attributeNames[uint8(" + featureConst + ")]"
		if !strings.Contains(code, needle) {
			t.Errorf("missing attribute table for %s", def.Name)
		}

		// Check that global attributes are included
		if !strings.Contains(code, `"featureMap":    model.AttrIDFeatureMap`) {
			t.Error("missing global featureMap attribute")
		}
	}
}

func TestGenerateNameTables_AttributeEntries(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	// Spot-check specific attribute entries that match the hand-written tables
	checks := []string{
		`"acActivePower": features.MeasurementAttrACActivePower`,
		`"controlState": features.EnergyControlAttrControlState`,
		`"phaseCount": features.ElectricalAttrPhaseCount`,
		`"operatingState": features.StatusAttrOperatingState`,
		`"deviceId": features.DeviceInfoAttrDeviceID`,
		`"state": features.ChargingSessionAttrState`,
		`"signalSource": features.SignalsAttrSignalSource`,
		`"planId": features.PlanAttrPlanID`,
		`"tariffId": features.TariffAttrTariffID`,
		`"testEventTriggersEnabled": features.TestControlAttrTestEventTriggersEnabled`,
	}

	for _, check := range checks {
		if !strings.Contains(code, check) {
			t.Errorf("missing attribute entry: %s", check)
		}
	}
}

func TestGenerateNameTables_CommandEntries(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	// Spot-check command entries
	checks := []string{
		`"setTariff": features.TariffCmdSetTariff`,
		`"sendPriceSignal": features.SignalsCmdSendPriceSignal`,
		`"clearSignals": features.SignalsCmdClearSignals`,
		`"setLimit": features.EnergyControlCmdSetLimit`,
		`"stop": features.EnergyControlCmdStop`,
		`"requestPlan": features.PlanCmdRequestPlan`,
		`"setChargingMode": features.ChargingSessionCmdSetChargingMode`,
		`"removeZone": features.DeviceInfoCmdRemoveZone`,
		`"triggerTestEvent": features.TestControlCmdTriggerTestEvent`,
		// setCommissioningWindowDuration is in YAML -- should be generated
		`"setCommissioningWindowDuration": features.TestControlCmdSetCommissioningWindowDuration`,
	}

	for _, check := range checks {
		if !strings.Contains(code, check) {
			t.Errorf("missing command entry: %s", check)
		}
	}
}

func TestGenerateNameTables_FeatureCount(t *testing.T) {
	endpointTypes, featureTypes, allDefs := loadTestData(t)

	code, err := GenerateNameTables(endpointTypes, featureTypes, allDefs)
	if err != nil {
		t.Fatalf("GenerateNameTables: %v", err)
	}

	// Should have exactly 10 feature attribute tables
	count := strings.Count(code, "attributeNames[uint8(model.Feature")
	if count != 10 {
		t.Errorf("expected 10 feature attribute tables, got %d", count)
	}
}
