package main

import (
	"fmt"
	"strings"

	"github.com/mash-protocol/mash-go/pkg/specparse"
)

// GenerateNameTables produces Go source for pkg/inspect/names_gen.go.
// It generates lookup tables mapping human-readable names to IDs for
// endpoints, features, attributes, and commands.
func GenerateNameTables(
	endpointTypes []specparse.RawModelTypeDef,
	featureTypes []specparse.RawModelTypeDef,
	allDefs []*specparse.RawFeatureDef,
) (string, error) {
	var b strings.Builder

	b.WriteString("// Code generated by mash-featgen. DO NOT EDIT.\n\n")
	b.WriteString("package inspect\n\n")

	// Endpoint names: SCREAMING_SNAKE -> lowercase no-underscore, mapped to model constant.
	b.WriteString("// generatedEndpointNames returns the endpoint name lookup table.\n")
	b.WriteString("func generatedEndpointNames() map[string]uint8 {\n")
	b.WriteString("\treturn map[string]uint8{\n")
	for _, ep := range endpointTypes {
		lowerKey := strings.ToLower(strings.ReplaceAll(ep.Name, "_", ""))
		goConst := "model." + toEndpointGoName(ep.Name)
		fmt.Fprintf(&b, "\t\t%q: uint8(%s),\n", lowerKey, goConst)
	}
	b.WriteString("\t}\n}\n\n")

	// Feature names: PascalCase -> lowercase, mapped to model constant.
	b.WriteString("// generatedFeatureNames returns the feature name lookup table.\n")
	b.WriteString("func generatedFeatureNames() map[string]uint8 {\n")
	b.WriteString("\treturn map[string]uint8{\n")
	for _, ft := range featureTypes {
		lowerKey := strings.ToLower(ft.Name)
		goConst := "model.Feature" + ft.Name
		fmt.Fprintf(&b, "\t\t%q: uint8(%s),\n", lowerKey, goConst)
	}
	b.WriteString("\t}\n}\n\n")

	// Attribute and command tables populated in a single init function.
	b.WriteString("// initGeneratedNameTables populates the attribute and command name tables.\n")
	b.WriteString("func initGeneratedNameTables() {\n")

	// Global attributes
	b.WriteString("\tglobalAttrs := map[string]uint16{\n")
	b.WriteString("\t\t\"featureMap\":    model.AttrIDFeatureMap,\n")
	b.WriteString("\t\t\"attributeList\": model.AttrIDAttributeList,\n")
	b.WriteString("\t\t\"commandList\":   model.AttrIDCommandList,\n")
	b.WriteString("\t}\n\n")

	// Per-feature attribute tables
	for _, def := range allDefs {
		if len(def.Attributes) == 0 {
			continue
		}
		varName := featureVarName(def.Name) + "Attrs"
		featureConst := "model.Feature" + def.Name

		fmt.Fprintf(&b, "\t%s := map[string]uint16{\n", varName)
		for _, attr := range def.Attributes {
			constName := "features." + def.Name + "Attr" + goTitleCase(attr.Name)
			fmt.Fprintf(&b, "\t\t%q: %s,\n", attr.Name, constName)
		}
		fmt.Fprintf(&b, "\t}\n")
		fmt.Fprintf(&b, "\tfor k, v := range globalAttrs {\n")
		fmt.Fprintf(&b, "\t\t%s[k] = v\n", varName)
		fmt.Fprintf(&b, "\t}\n")
		fmt.Fprintf(&b, "\tattributeNames[uint8(%s)] = %s\n\n", featureConst, varName)
	}

	// Per-feature command tables
	for _, def := range allDefs {
		if len(def.Commands) == 0 {
			continue
		}
		featureConst := "model.Feature" + def.Name

		fmt.Fprintf(&b, "\tcommandNames[uint8(%s)] = map[string]uint8{\n", featureConst)
		for _, cmd := range def.Commands {
			constName := "features." + def.Name + "Cmd" + goTitleCase(cmd.Name)
			fmt.Fprintf(&b, "\t\t%q: %s,\n", cmd.Name, constName)
		}
		fmt.Fprintf(&b, "\t}\n\n")
	}

	b.WriteString("}\n")

	return b.String(), nil
}

// featureVarName converts "EnergyControl" to "energyControl" for local variable names.
func featureVarName(name string) string {
	if name == "" {
		return ""
	}
	return strings.ToLower(name[:1]) + name[1:]
}
