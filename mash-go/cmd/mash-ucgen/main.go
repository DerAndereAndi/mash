// Command mash-ucgen generates Go use case definitions from YAML files.
//
// It reads YAML use case definitions from an input directory, resolves
// feature/attribute/command names against the MASH spec manifest, and writes
// a Go source file containing a pre-resolved Registry map.
//
// Usage:
//
//	mash-ucgen -input <dir> -output <file> -version <spec-version>
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/mash-protocol/mash-go/pkg/usecase"
)

func main() {
	var (
		inputDir   string
		outputFile string
		specVer    string
	)

	flag.StringVar(&inputDir, "input", "", "Input directory containing YAML use case files")
	flag.StringVar(&outputFile, "output", "", "Output Go source file path")
	flag.StringVar(&specVer, "version", "1.0", "Spec version for name resolution")
	flag.Parse()

	if inputDir == "" || outputFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	if err := runGenerator(inputDir, outputFile, specVer); err != nil {
		log.Fatalf("Error: %v", err)
	}
}

func runGenerator(inputDir, outputFile, specVer string) error {
	// Read all YAML files
	entries, err := os.ReadDir(inputDir)
	if err != nil {
		return fmt.Errorf("reading input directory %s: %w", inputDir, err)
	}

	var defs []*usecase.UseCaseDef

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".yaml") {
			continue
		}

		data, err := os.ReadFile(filepath.Join(inputDir, entry.Name()))
		if err != nil {
			return fmt.Errorf("reading %s: %w", entry.Name(), err)
		}

		raw, err := usecase.ParseRawUseCaseDef(data)
		if err != nil {
			return fmt.Errorf("parsing %s: %w", entry.Name(), err)
		}

		def, err := usecase.ResolveUseCaseDef(raw)
		if err != nil {
			return fmt.Errorf("resolving %s: %w", entry.Name(), err)
		}

		defs = append(defs, def)
	}

	if len(defs) == 0 {
		return fmt.Errorf("no YAML files found in %s", inputDir)
	}

	// Sort by ID for deterministic output
	sort.Slice(defs, func(i, j int) bool {
		return defs[i].ID < defs[j].ID
	})

	// Generate Go source
	src := generateGoSource(defs, specVer)

	// Write output
	if err := os.WriteFile(outputFile, []byte(src), 0o644); err != nil {
		return fmt.Errorf("writing output: %w", err)
	}

	return nil
}

func generateGoSource(defs []*usecase.UseCaseDef, specVer string) string {
	var b strings.Builder

	b.WriteString("// Code generated by mash-ucgen. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("// Source: docs/usecases/%s/*.yaml\n\n", specVer))
	b.WriteString("//go:generate go run ../../cmd/mash-ucgen -input ../../../docs/usecases/")
	b.WriteString(specVer)
	b.WriteString(" -output definitions_gen.go -version ")
	b.WriteString(specVer)
	b.WriteString("\n\n")
	b.WriteString("package usecase\n\n")

	// Registry keyed by UseCaseName (primary lookup for existing code)
	b.WriteString("// Registry maps use case names to their resolved definitions.\n")
	b.WriteString("var Registry = map[UseCaseName]*UseCaseDef{\n")

	for _, def := range defs {
		b.WriteString(fmt.Sprintf("\t%q: {\n", string(def.Name)))
		b.WriteString(fmt.Sprintf("\t\tName:        %q,\n", string(def.Name)))
		b.WriteString(fmt.Sprintf("\t\tID:          0x%02X,\n", uint16(def.ID)))
		b.WriteString(fmt.Sprintf("\t\tFullName:    %q,\n", def.FullName))
		b.WriteString(fmt.Sprintf("\t\tDescription: %q,\n", def.Description))
		b.WriteString(fmt.Sprintf("\t\tSpecVersion: %q,\n", def.SpecVersion))
		b.WriteString(fmt.Sprintf("\t\tMajor:       %d,\n", def.Major))
		b.WriteString(fmt.Sprintf("\t\tMinor:       %d,\n", def.Minor))

		// EndpointTypes
		if len(def.EndpointTypes) > 0 {
			b.WriteString("\t\tEndpointTypes: []string{")
			for i, et := range def.EndpointTypes {
				if i > 0 {
					b.WriteString(", ")
				}
				b.WriteString(fmt.Sprintf("%q", et))
			}
			b.WriteString("},\n")
		}

		// Scenarios
		if len(def.Scenarios) > 0 {
			b.WriteString("\t\tScenarios: []ScenarioDef{\n")
			for _, sd := range def.Scenarios {
				b.WriteString("\t\t\t{\n")
				b.WriteString(fmt.Sprintf("\t\t\t\tBit:         %d,\n", sd.Bit))
				b.WriteString(fmt.Sprintf("\t\t\t\tName:        %q,\n", sd.Name))
				b.WriteString(fmt.Sprintf("\t\t\t\tDescription: %q,\n", sd.Description))

				if len(sd.Features) > 0 {
					b.WriteString("\t\t\t\tFeatures: []FeatureRequirement{\n")
					for _, fr := range sd.Features {
						writeFeatureReq(&b, &fr, "\t\t\t\t\t")
					}
					b.WriteString("\t\t\t\t},\n")
				}

				b.WriteString("\t\t\t},\n")
			}
			b.WriteString("\t\t},\n")
		}

		// Commands
		if len(def.Commands) > 0 {
			b.WriteString("\t\tCommands: []string{")
			for i, cmd := range def.Commands {
				if i > 0 {
					b.WriteString(", ")
				}
				b.WriteString(fmt.Sprintf("%q", cmd))
			}
			b.WriteString("},\n")
		}

		b.WriteString("\t},\n")
	}

	b.WriteString("}\n\n")

	// NameToID map
	b.WriteString("// NameToID maps human-readable use case names to their wire IDs.\n")
	b.WriteString("var NameToID = map[UseCaseName]UseCaseID{\n")
	for _, def := range defs {
		b.WriteString(fmt.Sprintf("\t%q: 0x%02X,\n", string(def.Name), uint16(def.ID)))
	}
	b.WriteString("}\n\n")

	// IDToName map
	b.WriteString("// IDToName maps wire IDs to human-readable use case names.\n")
	b.WriteString("var IDToName = map[UseCaseID]UseCaseName{\n")
	for _, def := range defs {
		b.WriteString(fmt.Sprintf("\t0x%02X: %q,\n", uint16(def.ID), string(def.Name)))
	}
	b.WriteString("}\n\n")

	b.WriteString("func boolPtr(v bool) *bool { return &v }\n")

	return b.String()
}

func writeFeatureReq(b *strings.Builder, fr *usecase.FeatureRequirement, indent string) {
	b.WriteString(indent + "{\n")
	b.WriteString(fmt.Sprintf("%s\tFeatureName: %q,\n", indent, fr.FeatureName))
	b.WriteString(fmt.Sprintf("%s\tFeatureID:   0x%02x,\n", indent, fr.FeatureID))
	if fr.Required {
		b.WriteString(fmt.Sprintf("%s\tRequired:    true,\n", indent))
	}

	// Attributes
	if len(fr.Attributes) > 0 {
		b.WriteString(fmt.Sprintf("%s\tAttributes: []AttributeRequirement{\n", indent))
		for _, ar := range fr.Attributes {
			b.WriteString(fmt.Sprintf("%s\t\t{", indent))
			b.WriteString(fmt.Sprintf("Name: %q, AttrID: %d", ar.Name, ar.AttrID))
			if ar.RequiredValue != nil {
				b.WriteString(fmt.Sprintf(", RequiredValue: boolPtr(%v)", *ar.RequiredValue))
			}
			b.WriteString("},\n")
		}
		b.WriteString(fmt.Sprintf("%s\t},\n", indent))
	}

	// Commands
	if len(fr.Commands) > 0 {
		b.WriteString(fmt.Sprintf("%s\tCommands: []CommandRequirement{\n", indent))
		for _, cr := range fr.Commands {
			b.WriteString(fmt.Sprintf("%s\t\t{Name: %q, CommandID: %d},\n", indent, cr.Name, cr.CommandID))
		}
		b.WriteString(fmt.Sprintf("%s\t},\n", indent))
	}

	// Subscriptions
	if fr.SubscribeAll {
		b.WriteString(fmt.Sprintf("%s\tSubscribeAll: true,\n", indent))
	}

	b.WriteString(indent + "},\n")
}
