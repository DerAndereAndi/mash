// Command mash-ucgen generates Go use case definitions from YAML files.
//
// It reads YAML use case definitions from an input directory, resolves
// feature/attribute/command names against the MASH spec manifest, and writes
// a Go source file containing a pre-resolved Registry map.
//
// Usage:
//
//	mash-ucgen -input <dir> -output <file> -version <spec-version>
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/mash-protocol/mash-go/pkg/usecase"
)

func main() {
	var (
		inputDir   string
		outputFile string
		specVer    string
	)

	flag.StringVar(&inputDir, "input", "", "Input directory containing YAML use case files")
	flag.StringVar(&outputFile, "output", "", "Output Go source file path")
	flag.StringVar(&specVer, "version", "1.0", "Spec version for name resolution")
	flag.Parse()

	if inputDir == "" || outputFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	if err := runGenerator(inputDir, outputFile, specVer); err != nil {
		log.Fatalf("Error: %v", err)
	}
}

func runGenerator(inputDir, outputFile, specVer string) error {
	// Read all YAML files
	entries, err := os.ReadDir(inputDir)
	if err != nil {
		return fmt.Errorf("reading input directory %s: %w", inputDir, err)
	}

	var defs []*usecase.UseCaseDef

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".yaml") {
			continue
		}

		data, err := os.ReadFile(filepath.Join(inputDir, entry.Name()))
		if err != nil {
			return fmt.Errorf("reading %s: %w", entry.Name(), err)
		}

		raw, err := usecase.ParseRawUseCaseDef(data)
		if err != nil {
			return fmt.Errorf("parsing %s: %w", entry.Name(), err)
		}

		def, err := usecase.ResolveUseCaseDef(raw)
		if err != nil {
			return fmt.Errorf("resolving %s: %w", entry.Name(), err)
		}

		defs = append(defs, def)
	}

	if len(defs) == 0 {
		return fmt.Errorf("no YAML files found in %s", inputDir)
	}

	// Sort by name for deterministic output
	sort.Slice(defs, func(i, j int) bool {
		return defs[i].Name < defs[j].Name
	})

	// Generate Go source
	src := generateGoSource(defs, specVer)

	// Write output
	if err := os.WriteFile(outputFile, []byte(src), 0o644); err != nil {
		return fmt.Errorf("writing output: %w", err)
	}

	return nil
}

func generateGoSource(defs []*usecase.UseCaseDef, specVer string) string {
	var b strings.Builder

	b.WriteString("// Code generated by mash-ucgen. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("// Source: docs/usecases/%s/*.yaml\n\n", specVer))
	b.WriteString("//go:generate go run ../../cmd/mash-ucgen -input ../../../docs/usecases/")
	b.WriteString(specVer)
	b.WriteString(" -output definitions_gen.go -version ")
	b.WriteString(specVer)
	b.WriteString("\n\n")
	b.WriteString("package usecase\n\n")
	b.WriteString("// Registry maps use case names to their resolved definitions.\n")
	b.WriteString("var Registry = map[UseCaseName]*UseCaseDef{\n")

	for _, def := range defs {
		b.WriteString(fmt.Sprintf("\t%q: {\n", string(def.Name)))
		b.WriteString(fmt.Sprintf("\t\tName:        %q,\n", string(def.Name)))
		b.WriteString(fmt.Sprintf("\t\tFullName:    %q,\n", def.FullName))
		b.WriteString(fmt.Sprintf("\t\tDescription: %q,\n", def.Description))
		b.WriteString(fmt.Sprintf("\t\tSpecVersion: %q,\n", def.SpecVersion))

		// EndpointTypes
		if len(def.EndpointTypes) > 0 {
			b.WriteString("\t\tEndpointTypes: []string{")
			for i, et := range def.EndpointTypes {
				if i > 0 {
					b.WriteString(", ")
				}
				b.WriteString(fmt.Sprintf("%q", et))
			}
			b.WriteString("},\n")
		}

		// Features
		if len(def.Features) > 0 {
			b.WriteString("\t\tFeatures: []FeatureRequirement{\n")
			for _, fr := range def.Features {
				b.WriteString("\t\t\t{\n")
				b.WriteString(fmt.Sprintf("\t\t\t\tFeatureName: %q,\n", fr.FeatureName))
				b.WriteString(fmt.Sprintf("\t\t\t\tFeatureID:   0x%02x,\n", fr.FeatureID))
				b.WriteString(fmt.Sprintf("\t\t\t\tRequired:    %v,\n", fr.Required))

				// Attributes
				if len(fr.Attributes) > 0 {
					b.WriteString("\t\t\t\tAttributes: []AttributeRequirement{\n")
					for _, ar := range fr.Attributes {
						b.WriteString("\t\t\t\t\t{")
						b.WriteString(fmt.Sprintf("Name: %q, AttrID: %d", ar.Name, ar.AttrID))
						if ar.RequiredValue != nil {
							b.WriteString(fmt.Sprintf(", RequiredValue: boolPtr(%v)", *ar.RequiredValue))
						}
						b.WriteString("},\n")
					}
					b.WriteString("\t\t\t\t},\n")
				}

				// Commands
				if len(fr.Commands) > 0 {
					b.WriteString("\t\t\t\tCommands: []CommandRequirement{\n")
					for _, cr := range fr.Commands {
						b.WriteString(fmt.Sprintf("\t\t\t\t\t{Name: %q, CommandID: %d},\n", cr.Name, cr.CommandID))
					}
					b.WriteString("\t\t\t\t},\n")
				}

				// Subscriptions
				if fr.SubscribeAll {
					b.WriteString("\t\t\t\tSubscribeAll: true,\n")
				} else if len(fr.Subscriptions) > 0 {
					b.WriteString("\t\t\t\tSubscriptions: []SubscriptionDef{\n")
					for _, sd := range fr.Subscriptions {
						b.WriteString(fmt.Sprintf("\t\t\t\t\t{Name: %q, AttrID: %d},\n", sd.Name, sd.AttrID))
					}
					b.WriteString("\t\t\t\t},\n")
				}

				b.WriteString("\t\t\t},\n")
			}
			b.WriteString("\t\t},\n")
		}

		// Commands
		if len(def.Commands) > 0 {
			b.WriteString("\t\tCommands: []string{")
			for i, cmd := range def.Commands {
				if i > 0 {
					b.WriteString(", ")
				}
				b.WriteString(fmt.Sprintf("%q", cmd))
			}
			b.WriteString("},\n")
		}

		b.WriteString("\t},\n")
	}

	b.WriteString("}\n\n")
	b.WriteString("func boolPtr(v bool) *bool { return &v }\n")

	return b.String()
}
